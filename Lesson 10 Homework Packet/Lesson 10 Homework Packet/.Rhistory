load("~/Google Drive/DS 705 /Class Materials /Weekly Content/week 12/download_week_12/hotdogs.rda")
TukeyHSD(aov(calories~type,data=hotdogs))
tk <- onewayComp(calories~type, data=hotdogs, var.equal=TRUE, alpha=.1)
tk
source('./onewayComp.R') # included in weekly download
setwd("~/Google Drive/DS 705 /Class Materials /Weekly Content/week 07/download")
onewayComp(scoreInc~group, data=d, var.equal=T)$comp[,c(1,2,3,6)]
source('./onewayComp.R') # included in weekly download
source('~/.active-rstudio-document', echo=TRUE)
source('~/Google Drive/DS 705 /Class Materials /Weekly Content/week 07/download/onewayComp.R')
source('~/Google Drive/DS 705 /Class Materials /Weekly Content/week 07/download/onewayComp.R')
require(DS705data)
instal.packages("DS705data")
install.packages("DS705data")
require(DS705data)
?onewayComp
install.packages('multcompView')
require(DS705data)
out <- onewayComp(RPM~Type, var.equal = T, adjust = 'one.step')$comp[,c(2,3)]
if (!require(MASS)){
install.packages('MASS')
library(MASS)
}
data(Cars93)
Cars93 <- Cars93[Cars93$Type != 'Van',]
Cars93$Type <- factor(Cars93$Type) # recasting Type forces the factor levels to reset
Cars93$Type <- factor(Cars93$Type,labels=c('Cm','Lg','Md','Sm','Sp'))
attach(Cars93)
summary(Price) # Price is one of the variables in the Cars93 data frame, after attaching we don't have to refer to the data frame.  Don't forget to detach(Cars93) after you're done.
require(DS705data)
out <- onewayComp(RPM~Type, var.equal = T, adjust = 'one.step')$comp[,c(2,3)]
require(multcompView)
padj_extract <- function(formula,data){out$comp[,'p adj']}
multcompBoxplot(RPM~Type,data=Cars93,horizontal=T,compFn="padj_extract")
out
out <- onewayComp(RPM~Type, var.equal = T, adjust = 'one.step')
require(multcompView)
require(multcompView)
padj_extract <- function(formula,data){out$comp[,'p adj']}
multcompBoxplot(RPM~Type,data=Cars93,horizontal=T,compFn="padj_extract")
install.packages('dunn.test')
332*3*875
knitr::opts_chunk$set(echo = TRUE)
# don't modify this block.
# the distAssign and demrepFit functions go along with problem 13.10-6 from the textbook.
# demrepFit is the function to optimize
cities = matrix(c(152,81,75,34,62,38,48,74,98,66,83,86,72,28,112,45,93,72,
62,59,83,52,87,87,69,49,62,72,75,82,83,53,98,82,68,98),18,2);
distAssign <- function(x){
# x is an input of 18 integers 1..10 that assign city 1..18 to districts 1..10
# distAssign is a dataframe with the number of Democrats, Republicans, Total, and Winner
# in each of the 10 districts
sumdem = numeric(10);
sumrep = numeric(10);
sumtot = numeric(10);
for (i in 1:10){
sumdem[i] = sum( cities[x==i,1] );
sumrep[i] = sum( cities[x==i,2] );
sumtot[i] = sumdem[i] + sumrep[i];
}
distAssign <- data.frame( Dem = sumdem, Rep = sumrep, Tot = sumtot, Win = sumrep>sumdem );
}
demrepFit <- function(x){
# x is an input of 18 integers 1..10 that assign city 1..18 to districts 1..10
# demrepfit is the number of districts where Republicans have a majority
# subtract a penalty proportional to amount by which constraints are violated
#
df <- distAssign(x);
numRepDist = sum(df$Win);
sumtot = df$Tot;
# total number of voters is between 150 mil and 350 mil in each district
# to enforce this constraint we subtract a penalty term equal to the total amount this
# constraint is violated
demrepFit = numRepDist - ( sum( 150-sumtot[sumtot<150] )  + sum( sumtot[sumtot>350]-350 ) );
# if the algorithm you use minimizes the fitness instead of maximizing, then
# uncomment the next line, if your routine maximizes then the next line should be
# commented out
demrepFit = -demrepFit;
}
# Notice the constraints aren't explicitly enforced, but instead a penalty term is included in the
# fitness function to encourage the genetic algorithm to seek potential solutions that satisfy
# the constraints.
library('gramEvol')
install.packages('gramEvol')
library('gramEvol')
GA <- GeneticAlg.int(18,1,10,allowrepeat = TRUE,popSize=50,iterations=200,evalFunc=demrepFit) # find minimum
df <- distAssign(GA$best$genome);
df
demrepFit <- function(x){
# x is an input of 18 integers 1..10 that assign city 1..18 to districts 1..10
# demrepfit is the number of districts where Republicans have a majority
# subtract a penalty proportional to amount by which constraints are violated
#
df <- distAssign(x);
numRepDist = sum(df$Win);
sumtot = df$Tot;
# total number of voters is between 150 mil and 350 mil in each district
# to enforce this constraint we subtract a penalty term equal to the total amount this
# constraint is violated
demrepFit = numRepDist - ( sum( 150-sumtot[sumtot<150] )  + sum( sumtot[sumtot>350]-350 ) );
# if the algorithm you use minimizes the fitness instead of maximizing, then
# uncomment the next line, if your routine maximizes then the next line should be
# commented out
#demrepFit = -demrepFit;
}
# you can delete the lines below, they are just there to show you how the functions work
#x = c(1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8); # a sample assignment
#(demrepFit(x)) # extra parentheses force R to print the result
# calling demrepFit(x) for sample x, yields -37
library(gramEvol)
z = 10
#monitorFunc <- function(result) {
#    cat("Best of gen: ", min(result$best$cost), "\n");
j = 1
for (j in z){
y<- GeneticAlg.int(genomeLen = 18, codonMin = 1, codonMax = 10,
allowrepeat = TRUE,mutationChance = 0.1,iterations=1000,
evalFunc = demrepFit); # demrepFit gives number of republican districts or negative number if constraints violated
if (j == 1)
{bestFit <- y$best$cost
bestGenome <- y$best$genome}
else
if (bestFit < y$best$cost)
{bestFit <- y$best$cost;
bestGenome <- y$best$genome;}
}
bestFit
bestGenome
demrepFit <- function(x){
# x is an input of 18 integers 1..10 that assign city 1..18 to districts 1..10
# demrepfit is the number of districts where Republicans have a majority
# subtract a penalty proportional to amount by which constraints are violated
#
df <- distAssign(x);
numRepDist = sum(df$Win);
sumtot = df$Tot;
# total number of voters is between 150 mil and 350 mil in each district
# to enforce this constraint we subtract a penalty term equal to the total amount this
# constraint is violated
demrepFit = numRepDist - ( sum( 150-sumtot[sumtot<150] )  + sum( sumtot[sumtot>350]-350 ) );
# if the algorithm you use minimizes the fitness instead of maximizing, then
# uncomment the next line, if your routine maximizes then the next line should be
# commented out
#demrepFit = -demrepFit;
}
# you can delete the lines below, they are just there to show you how the functions work
#x = c(1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8); # a sample assignment
#(demrepFit(x)) # extra parentheses force R to print the result
# calling demrepFit(x) for sample x, yields -37
library(gramEvol)
z = 10
#monitorFunc <- function(result) {
#    cat("Best of gen: ", min(result$best$cost), "\n");
j = 1
for (j in 1:z){
y<- GeneticAlg.int(genomeLen = 18, codonMin = 1, codonMax = 10,
allowrepeat = TRUE,mutationChance = 0.1,iterations=1000,
evalFunc = demrepFit); # demrepFit gives number of republican districts or negative number if constraints violated
if (j == 1)
{bestFit <- y$best$cost
bestGenome <- y$best$genome}
else
if (bestFit < y$best$cost)
{bestFit <- y$best$cost;
bestGenome <- y$best$genome;}
}
bestFit
bestGenome
?ga
library('GA')
?ga
?GeneticAlg.int
demrepFit <- function(x){
# x is an input of 18 integers 1..10 that assign city 1..18 to districts 1..10
# demrepfit is the number of districts where Republicans have a majority
# subtract a penalty proportional to amount by which constraints are violated
#
df <- distAssign(x);
numRepDist = sum(df$Win);
sumtot = df$Tot;
# total number of voters is between 150 mil and 350 mil in each district
# to enforce this constraint we subtract a penalty term equal to the total amount this
# constraint is violated
demrepFit = numRepDist - ( sum( 150-sumtot[sumtot<150] )  + sum( sumtot[sumtot>350]-350 ) );
# if the algorithm you use minimizes the fitness instead of maximizing, then
# uncomment the next line, if your routine maximizes then the next line should be
# commented out
demrepFit = -demrepFit;
}
# you can delete the lines below, they are just there to show you how the functions work
#x = c(1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8); # a sample assignment
#(demrepFit(x)) # extra parentheses force R to print the result
# calling demrepFit(x) for sample x, yields -37
library(gramEvol)
z = 10
#monitorFunc <- function(result) {
#    cat("Best of gen: ", min(result$best$cost), "\n");
j = 1
for (j in 1:z){
y<- GeneticAlg.int(genomeLen = 18, codonMin = 1, codonMax = 10,
allowrepeat = TRUE,iterations=100,
evalFunc = demrepFit); # demrepFit gives number of republican districts or negative number if constraints violated
if (j == 1)
{bestFit <- y$best$cost
bestGenome <- y$best$genome}
else
if (bestFit < y$best$cost)
{bestFit <- y$best$cost;
bestGenome <- y$best$genome;}
}
bestFit
bestGenome
Rastrigin <- function(x) {
-(sum(x^2 - 10 * cos(2 * pi  * x)) + 10 * length(x))
}
dimension = 10;
lower = rep(-5.12,dimension);
upper = rep(5.12,dimension);
set.seed(123) # for reproducible results
result = ga(type="real-valued",fitness=Rastrigin,min=lower,max=upper,maxiter=500);
round(result@solution,5)
result@fitnessValue
result = ga(type="real-valued",fitness=Rastrigin,
min=lower,max=upper,maxiter=1000,optim=TRUE)
?ga
?GA
demrepFit <- function(x){
# x is an input of 18 integers 1..10 that assign city 1..18 to districts 1..10
# demrepfit is the number of districts where Republicans have a majority
# subtract a penalty proportional to amount by which constraints are violated
#
df <- distAssign(x);
numRepDist = sum(df$Win);
sumtot = df$Tot;
# total number of voters is between 150 mil and 350 mil in each district
# to enforce this constraint we subtract a penalty term equal to the total amount this
# constraint is violated
demrepFit = numRepDist - ( sum( 150-sumtot[sumtot<150] )  + sum( sumtot[sumtot>350]-350 ) );
# if the algorithm you use minimizes the fitness instead of maximizing, then
# uncomment the next line, if your routine maximizes then the next line should be
# commented out
demrepFit = -demrepFit;
}
# you can delete the lines below, they are just there to show you how the functions work
#x = c(1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8); # a sample assignment
#(demrepFit(x)) # extra parentheses force R to print the result
# calling demrepFit(x) for sample x, yields -37
library(gramEvol)
z = 10
#monitorFunc <- function(result) {
#    cat("Best of gen: ", min(result$best$cost), "\n");
j = 1
for (j in 1:z){
y<- GeneticAlg.int(genomeLen = 18, codonMin = 1, codonMax = 10,
allowrepeat = TRUE,mutationChance = 0.1,iterations=1000,
evalFunc = demrepFit); # demrepFit gives number of republican districts or negative number if constraints violated
if (j == 1)
{bestFit <- y$best$cost
bestGenome <- y$best$genome}
else
if (bestFit < y$best$cost)
{bestFit <- y$best$cost;
bestGenome <- y$best$genome;}
}
bestFit
bestGenome
demrepFit <- function(x){
# x is an input of 18 integers 1..10 that assign city 1..18 to districts 1..10
# demrepfit is the number of districts where Republicans have a majority
# subtract a penalty proportional to amount by which constraints are violated
#
df <- distAssign(x);
numRepDist = sum(df$Win);
sumtot = df$Tot;
# total number of voters is between 150 mil and 350 mil in each district
# to enforce this constraint we subtract a penalty term equal to the total amount this
# constraint is violated
demrepFit = numRepDist - ( sum( 150-sumtot[sumtot<150] )  + sum( sumtot[sumtot>350]-350 ) );
# if the algorithm you use minimizes the fitness instead of maximizing, then
# uncomment the next line, if your routine maximizes then the next line should be
# commented out
demrepFit = -demrepFit;
}
# you can delete the lines below, they are just there to show you how the functions work
#x = c(1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8); # a sample assignment
#(demrepFit(x)) # extra parentheses force R to print the result
# calling demrepFit(x) for sample x, yields -37
library(gramEvol)
z = 10
#monitorFunc <- function(result) {
#    cat("Best of gen: ", min(result$best$cost), "\n");
j = 1
for (j in 1:z){
y<- GeneticAlg.int(genomeLen = 18, codonMin = 1, codonMax = 10,
allowrepeat = TRUE,iterations=100,
evalFunc = demrepFit); # demrepFit gives number of republican districts or negative number if constraints violated
if (j == 1)
{bestFit <- y$best$cost
bestGenome <- y$best$genome}
else
if (bestFit < y$best$cost)
{bestFit <- y$best$cost;
bestGenome <- y$best$genome;}
}
bestFit
bestGenome
demrepFit <- function(x){
# x is an input of 18 integers 1..10 that assign city 1..18 to districts 1..10
# demrepfit is the number of districts where Republicans have a majority
# subtract a penalty proportional to amount by which constraints are violated
#
df <- distAssign(x);
numRepDist = sum(df$Win);
sumtot = df$Tot;
# total number of voters is between 150 mil and 350 mil in each district
# to enforce this constraint we subtract a penalty term equal to the total amount this
# constraint is violated
demrepFit = numRepDist - ( sum( 150-sumtot[sumtot<150] )  + sum( sumtot[sumtot>350]-350 ) );
# if the algorithm you use minimizes the fitness instead of maximizing, then
# uncomment the next line, if your routine maximizes then the next line should be
# commented out
demrepFit = -demrepFit;
}
# you can delete the lines below, they are just there to show you how the functions work
#x = c(1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8); # a sample assignment
#(demrepFit(x)) # extra parentheses force R to print the result
# calling demrepFit(x) for sample x, yields -37
library(gramEvol)
z = 10
#monitorFunc <- function(result) {
#    cat("Best of gen: ", min(result$best$cost), "\n");
j = 1
for (j in 1:z){
y<- GeneticAlg.int(genomeLen = 18, codonMin = 1, codonMax = 10,
allowrepeat = TRUE,iterations=200,
evalFunc = demrepFit); # demrepFit gives number of republican districts or negative number if constraints violated
if (j == 1)
{bestFit <- y$best$cost
bestGenome <- y$best$genome}
else
if (bestFit < y$best$cost)
{bestFit <- y$best$cost;
bestGenome <- y$best$genome;}
}
bestFit
bestGenome
# Do not change this chunk
set.seed(124)
T0 = 900;
T1 = 100;
x = c( rnorm(T0), rnorm(T1, mean = 3))
P = pnorm(x, lower.tail = FALSE )
P
sum(P < .05)
# FALSE means reject null = discovery
test <- P > 0.05
test0 <- test[1:T0]
test1 <- test[(T0+1):(T0+T1)]
summary(test0)
summary(test1)
# the type I error rate is
sum(test0==FALSE)/T0
# the type II error rate is
sum(test1==TRUE)/T1
# the false discovery rate is
sum(test0==FALSE) / (sum(test0==FALSE) + sum(test1==FALSE))
# the type I error rate is
sum(test0==FALSE)/T0
# the type I error rate is
sum(test0==FALSE)/T0
test0
test0 <- test[1:T0]
test1 <- test[(T0+1):(T0+T1)]
summary(test0)
summary(test1)
