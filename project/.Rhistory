#remove NAs from bcOpen, there are 360.
loans <- loans[which(!is.na(loans$bcOpen)),]
filePath <- "C:/Users/matt/source/repos/ds705/project/loans50k.csv"
#filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
loans <- read.csv2(filePath, header = TRUE, sep = ",")
#filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
loans <- read.csv2(filePath, header = TRUE, sep = ",")
loans$response <- loans$status
loans$response <- loans$status
#Good loans are those that have a status of "Fully Paid". Bad loans are those that have a status of "Charged Off" or "Default".
levels(loans$response)[levels(loans$response)==c("Charged Off")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Default")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Fully Paid")] <- "Good"
loans <- loans[which(loans$response=="Bad" | loans$response=="Good"), ]
#remove unuused levels
loans$response <- factor(loans$response)
#transform Source Verified to Verified
levels(loans$verified)[levels(loans$verified)==c("Source Verified")] <- "Verified"
#remove unuused levels
loans$verified <- factor(loans$verified)
#experiment
summary(loans$bcOpen)
hist(log(loans$bcOpen))
summary(loans$totalBcLim)
hist(log(loans$totalBcLim))
#eliminate length, many missing values what is another a proxy? show count of n/a.
table(loans$length)
class(loans$length)
#1823 as n/a
length(which(loans$length == "n/a"))
columns_to_keep <- c("response","totalPaid", "amount", "debtIncRat","verified","income", "delinq2yr","inq6mth","payment", "bcOpen", "totalBcLim")
loans <- loans[columns_to_keep]
#convert income, amount, debtIncRat and totalPaid to numeric
loans$income <- as.numeric(as.character(loans$income))
loans$amount <- as.numeric(as.character(loans$amount))
loans$payment <- as.numeric(as.character(loans$payment))
loans$totalPaid <- as.numeric(as.character(loans$totalPaid))
loans$debtIncRat <- as.numeric(as.character(loans$debtIncRat))
#transform variables
loans$log_amount <- log(loans$amount)
loans$log_payment <- log(loans$payment)
loans$log_income <- log(loans$income)
#remove NAs from bcOpen, there are 360.
loans <- loans[which(!is.na(loans$bcOpen)),]
#replaced totalLim and totalBal etc with
loans$log_bcOpen <- log(loans$bcOpen)
loans$log_totalBcLim <- log(loans$totalBcLim)
loans$cube_rt_delinq2yr <- (loans$delinq2yr)^(1/3)
loans$cube_rt_inq6mth <- (loans$inq6mth)^(1/3)
log_amount_plot <- ggplot(loans, aes(x=log_amount)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
#https://stackoverflow.com/questions/17200114/how-to-split-data-into-training-testing-sets-using-sample-function
## 80% of the sample size
smp_size <- floor(0.8 * nrow(loans))
## set the seed to make your partition reproducible
set.seed(123)
train_ind <- sample(seq_len(nrow(loans)), size = smp_size)
train <- loans[train_ind, ]
test <- loans[-train_ind, ]
#cube_rt_delinq2yr +
loan.model <- glm(formula = response ~ log_amount + log_income + log_payment + verified + debtIncRat + cube_rt_inq6mth + log_bcOpen + log_totalBcLim, family = "binomial", data = train)
#experiment
summary(loans$bcOpen)
hist((loans$bcOpen)^(1/3))
summary(loans$totalBcLim)
hist((loans$totalBcLim)^(1/3))
#replaced totalLim and totalBal etc with
loans$cube_rt_bcOpen <- log(loans$bcOpen)^(1/3)
loans$cube_rt_totalBcLim <- log(loans$totalBcLim)^(1/3)
#cube_rt_delinq2yr +
loan.model <- glm(formula = response ~ log_amount + log_income + log_payment + verified + debtIncRat + cube_rt_inq6mth + cube_rt_bcOpen+cube_rt_totalBcLim, family = "binomial", data = train)
#replaced totalLim and totalBal etc with
loans$cube_rt_bcOpen <- log(loans$bcOpen)^(1/3)
loans$cube_rt_totalBcLim <- log(loans$totalBcLim)^(1/3)
#cube_rt_delinq2yr +
loan.model <- glm(formula = response ~ log_amount + log_income + log_payment + verified + debtIncRat + cube_rt_inq6mth + cube_rt_bcOpen+cube_rt_totalBcLim, family = "binomial", data = train)
#https://stackoverflow.com/questions/17200114/how-to-split-data-into-training-testing-sets-using-sample-function
## 80% of the sample size
smp_size <- floor(0.8 * nrow(loans))
## set the seed to make your partition reproducible
set.seed(123)
train_ind <- sample(seq_len(nrow(loans)), size = smp_size)
train <- loans[train_ind, ]
test <- loans[-train_ind, ]
#cube_rt_delinq2yr +
loan.model <- glm(formula = response ~ log_amount + log_income + log_payment + verified + debtIncRat + cube_rt_inq6mth + cube_rt_bcOpen+cube_rt_totalBcLim, family = "binomial", data = train)
extractAIC(loan.model)
summary(loan.model)
summary(test)
require(HH)
vif(response ~ log_amount + log_income + debtIncRat + cube_rt_delinq2yr + cube_rt_inq6mth + payment,  data = train)
#predprob <- fitted(loan.model) # get predicted probabilities
predprob <- predict(loan.model, test, type="response")
threshhold <- 0.5  # Set Y=1 when predicted probability exceeds this
predLoan <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
labels=c("Bad", "Good"))
cTab <- table(test$response, predLoan)
addmargins(cTab)
p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
print(paste('Proportion correctly predicted = ', p))
model.accuracy <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
predLoan <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
labels=c("Bad", "Good"))
cTab <- table(test$response, predLoan)
addmargins(cTab)
p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
}
threshholds <- seq(from = 0, to = 1, length.out = 30)
accuracy <- sapply(threshholds,model.accuracy)
accuracy.df <- data.frame(threshhold=threshholds, accuracy=accuracy)
#model is same accuracy from 0 to .5.
plot(accuracy~threshholds)
model.profit <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
profit.df <- test[which(predprob > threshhold),]
profit <- sum(profit.df$totalPaid - profit.df$amount)
}
threshholds <- seq(from = 0, to = 1, length.out = 30)
profit <- sapply(threshholds,model.profit)
threshholds[which.max(profit)] #threshold of max profit
plot(profit~threshholds)
#cube_rt_delinq2yr +
loan.model <- glm(formula = response ~ log_amount + log_income + log_payment + verified + debtIncRat + cube_rt_inq6mth + cube_rt_bcOpen:cube_rt_totalBcLim, family = "binomial", data = train)
extractAIC(loan.model)
summary(loan.model)
extractAIC(loan.model)
summary(loan.model)
require(HH)
vif(response ~ log_amount + log_income + debtIncRat + cube_rt_delinq2yr + cube_rt_inq6mth + payment,  data = train)
vif(response ~ log_amount + log_income + debtIncRat + cube_rt_delinq2yr + cube_rt_inq6mth + payment + cube_rt_bcOpen:cube_rt_totalBcLim,  data = train)
#predprob <- fitted(loan.model) # get predicted probabilities
predprob <- predict(loan.model, test, type="response")
threshhold <- 0.5  # Set Y=1 when predicted probability exceeds this
predLoan <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
labels=c("Bad", "Good"))
cTab <- table(test$response, predLoan)
addmargins(cTab)
p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
print(paste('Proportion correctly predicted = ', p))
#cube_rt_delinq2yr +
loan.model <- glm(formula = response ~ log_amount + log_income + log_payment + verified + debtIncRat + cube_rt_inq6mth + cube_rt_bcOpen + cube_rt_totalBcLim, family = "binomial", data = train)
extractAIC(loan.model)
vif(response ~ log_amount + log_income + log_payment + verified + debtIncRat + cube_rt_inq6mth + cube_rt_bcOpen + cube_rt_totalBcLim,  data = train)
#predprob <- fitted(loan.model) # get predicted probabilities
predprob <- predict(loan.model, test, type="response")
threshhold <- 0.5  # Set Y=1 when predicted probability exceeds this
predLoan <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
labels=c("Bad", "Good"))
cTab <- table(test$response, predLoan)
addmargins(cTab)
p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
print(paste('Proportion correctly predicted = ', p))
model.accuracy <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
predLoan <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
labels=c("Bad", "Good"))
cTab <- table(test$response, predLoan)
addmargins(cTab)
p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
}
threshholds <- seq(from = 0, to = 1, length.out = 30)
accuracy <- sapply(threshholds,model.accuracy)
accuracy.df <- data.frame(threshhold=threshholds, accuracy=accuracy)
View(accuracy.df)
View(accuracy.df)
#model is most accurate at around .5
plot(accuracy~threshholds)
hist((loans$bcOpen)^(1/3))
cube_rt_bcOpen_plot <- ggplot(loans, aes(x=cube_rt_bcOpen)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=1, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
log_amount_plot <- ggplot(loans, aes(x=log_amount)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
log_payment_plot <- ggplot(loans, aes(x=log_payment)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
log_income_plot <- ggplot(loans, aes(x=log_income)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
cube_rt_delinq2yr_plot <- ggplot(loans, aes(x=cube_rt_delinq2yr)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_inq6mth_plot <- ggplot(loans, aes(x=cube_rt_inq6mth)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_bcOpen_plot <- ggplot(loans, aes(x=cube_rt_bcOpen)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=1, colour="black", fill="white")
debtIncRat_plot <- ggplot(loans, aes(x=debtIncRat)) +
geom_histogram(binwidth=1, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
filePath <- "C:/Users/matt/source/repos/ds705/project/loans50k.csv"
#filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
loans <- read.csv2(filePath, header = TRUE, sep = ",")
loans$response <- loans$status
#Good loans are those that have a status of "Fully Paid". Bad loans are those that have a status of "Charged Off" or "Default".
levels(loans$response)[levels(loans$response)==c("Charged Off")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Default")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Fully Paid")] <- "Good"
loans <- loans[which(loans$response=="Bad" | loans$response=="Good"), ]
#remove unuused levels
loans$response <- factor(loans$response)
#transform Source Verified to Verified
levels(loans$verified)[levels(loans$verified)==c("Source Verified")] <- "Verified"
#remove unuused levels
loans$verified <- factor(loans$verified)
#experiment
summary(loans$bcOpen)
hist((loans$bcOpen)^(1/3))
summary(loans$totalBcLim)
hist((loans$totalBcLim)^(1/3))
#eliminate length, many missing values what is another a proxy? show count of n/a.
table(loans$length)
class(loans$length)
#1823 as n/a
length(which(loans$length == "n/a"))
columns_to_keep <- c("response","totalPaid", "amount", "debtIncRat","verified","income", "delinq2yr","inq6mth","payment", "bcOpen", "totalBcLim")
loans <- loans[columns_to_keep]
#convert income, amount, debtIncRat and totalPaid to numeric
loans$income <- as.numeric(as.character(loans$income))
loans$amount <- as.numeric(as.character(loans$amount))
loans$payment <- as.numeric(as.character(loans$payment))
loans$totalPaid <- as.numeric(as.character(loans$totalPaid))
loans$debtIncRat <- as.numeric(as.character(loans$debtIncRat))
#transform variables
loans$log_amount <- log(loans$amount)
loans$log_payment <- log(loans$payment)
loans$log_income <- log(loans$income)
#remove NAs from bcOpen, there are 360.
loans <- loans[which(!is.na(loans$bcOpen)),]
#replaced totalLim and totalBal etc with
loans$cube_rt_bcOpen <- log(loans$bcOpen)^(1/3)
loans$cube_rt_totalBcLim <- log(loans$totalBcLim)^(1/3)
loans$cube_rt_delinq2yr <- (loans$delinq2yr)^(1/3)
loans$cube_rt_inq6mth <- (loans$inq6mth)^(1/3)
log_amount_plot <- ggplot(loans, aes(x=log_amount)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
log_payment_plot <- ggplot(loans, aes(x=log_payment)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
log_income_plot <- ggplot(loans, aes(x=log_income)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
cube_rt_delinq2yr_plot <- ggplot(loans, aes(x=cube_rt_delinq2yr)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_inq6mth_plot <- ggplot(loans, aes(x=cube_rt_inq6mth)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_bcOpen_plot <- ggplot(loans, aes(x=cube_rt_bcOpen)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=1, colour="black", fill="white")
debtIncRat_plot <- ggplot(loans, aes(x=debtIncRat)) +
geom_histogram(binwidth=1, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
cube_rt_bcOpen_plot <- ggplot(loans, aes(x=cube_rt_bcOpen)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
debtIncRat_plot <- ggplot(loans, aes(x=debtIncRat)) +
geom_histogram(binwidth=1, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
cube_rt_bcOpen_plot <- ggplot(loans, aes(x=cube_rt_bcOpen)) +
geom_histogram(binwidth=.01, colour="black", fill="white")
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=.01, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
summary(loans$cube_rt_bcOpen)
summary(loans$bcOpen)
summary(loans$cube_rt_totalBcLim)
summary(loans$totalBcLim)
#replaced totalLim and totalBal etc with
loans$cube_rt_bcOpen <- (loans$bcOpen)^(1/3)
loans$cube_rt_totalBcLim <- (loans$totalBcLim)^(1/3)
summary(loans$cube_rt_bcOpen)
summary(loans$cube_rt_totalBcLim)
cube_rt_bcOpen_plot <- ggplot(loans, aes(x=cube_rt_bcOpen)) +
geom_histogram(binwidth=.01, colour="black", fill="white")
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=.01, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
cube_rt_bcOpen_plot <- ggplot(loans, aes(x=cube_rt_bcOpen)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
cube_rt_bcOpen_plot <- ggplot(loans, aes(x=cube_rt_bcOpen)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=1, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
summary(loans$bcOpen)
summary(loans$totalBcLim)
loans$cube_rt_totalBcLim <- log(loans$totalBcLim + 1)
summary(loans$cube_rt_totalBcLim)
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=1, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
filePath <- "C:/Users/matt/source/repos/ds705/project/loans50k.csv"
#filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
loans <- read.csv2(filePath, header = TRUE, sep = ",")
#Good loans are those that have a status of "Fully Paid". Bad loans are those that have a status of "Charged Off" or "Default".
levels(loans$response)[levels(loans$response)==c("Charged Off")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Default")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Fully Paid")] <- "Good"
loans <- loans[which(loans$response=="Bad" | loans$response=="Good"), ]
#remove unuused levels
loans$response <- factor(loans$response)
require(ggplot2)
require(ggplot2)
require(grid)
require(gridExtra)
#filePath <- "C:/Users/matt/source/repos/ds705/project/loans50k.csv"
filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
loans <- read.csv2(filePath, header = TRUE, sep = ",")
loans$response <- loans$status
#Good loans are those that have a status of "Fully Paid". Bad loans are those that have a status of "Charged Off" or "Default".
levels(loans$response)[levels(loans$response)==c("Charged Off")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Default")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Fully Paid")] <- "Good"
loans <- loans[which(loans$response=="Bad" | loans$response=="Good"), ]
#remove unuused levels
loans$response <- factor(loans$response)
#transform Source Verified to Verified
levels(loans$verified)[levels(loans$verified)==c("Source Verified")] <- "Verified"
#remove unuused levels
loans$verified <- factor(loans$verified)
#experiment
summary(loans$bcOpen)
hist((loans$bcOpen)^(1/3))
summary(loans$totalBcLim)
hist((loans$totalBcLim)^(1/3))
#eliminate length, many missing values what is another a proxy? show count of n/a.
table(loans$length)
class(loans$length)
#1823 as n/a
length(which(loans$length == "n/a"))
columns_to_keep <- c("response","totalPaid", "amount", "debtIncRat","verified","income", "delinq2yr","inq6mth","payment", "bcOpen", "totalBcLim")
loans <- loans[columns_to_keep]
#convert income, amount, debtIncRat and totalPaid to numeric
loans$income <- as.numeric(as.character(loans$income))
loans$amount <- as.numeric(as.character(loans$amount))
loans$payment <- as.numeric(as.character(loans$payment))
loans$totalPaid <- as.numeric(as.character(loans$totalPaid))
loans$debtIncRat <- as.numeric(as.character(loans$debtIncRat))
#transform variables
loans$log_amount <- log(loans$amount)
loans$log_payment <- log(loans$payment)
loans$log_income <- log(loans$income)
#remove NAs from bcOpen, there are 360.
loans <- loans[which(!is.na(loans$bcOpen)),]
#replaced totalLim and totalBal etc with
loans$cube_rt_bcOpen <- (loans$bcOpen)^(1/3)
summary(loans$cube_rt_bcOpen)
summary(loans$bcOpen)
loans$cube_rt_totalBcLim <- (loans$totalBcLim)^(1/3)
summary(loans$cube_rt_totalBcLim)
summary(loans$totalBcLim)
loans$cube_rt_delinq2yr <- (loans$delinq2yr)^(1/3)
loans$cube_rt_inq6mth <- (loans$inq6mth)^(1/3)
log_amount_plot <- ggplot(loans, aes(x=log_amount)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
log_payment_plot <- ggplot(loans, aes(x=log_payment)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
log_income_plot <- ggplot(loans, aes(x=log_income)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
cube_rt_delinq2yr_plot <- ggplot(loans, aes(x=cube_rt_delinq2yr)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_inq6mth_plot <- ggplot(loans, aes(x=cube_rt_inq6mth)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_bcOpen_plot <- ggplot(loans, aes(x=cube_rt_bcOpen)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=1, colour="black", fill="white")
debtIncRat_plot <- ggplot(loans, aes(x=debtIncRat)) +
geom_histogram(binwidth=1, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
log_amount_boxplot <- ggplot(aes(y = log_amount, x = response), data = loans) + geom_boxplot()
log_payment_boxplot <- ggplot(aes(y = log_payment, x = response), data = loans) + geom_boxplot()
log_income_boxplot <- ggplot(aes(y = log_income, x = response), data = loans) + geom_boxplot()
cube_rt_delinq2yr_boxplot <- ggplot(aes(y = cube_rt_delinq2yr, x = response), data = loans) + geom_boxplot()
cube_rt_inq6mth_boxplot <- ggplot(aes(y = cube_rt_inq6mth, x = response), data = loans) + geom_boxplot()
debtIncRat_boxplot <- ggplot(aes(y = debtIncRat, x = response), data = loans) + geom_boxplot()
cube_rt_bcOpen_boxplot <- ggplot(aes(y = cube_rt_bcOpen, x = response), data = loans) + geom_boxplot()
cube_rt_totalBcLim_boxplot <- ggplot(aes(y = cube_rt_totalBcLim, x = response), data = loans) + geom_boxplot()
grid.arrange(log_amount_boxplot, log_payment_boxplot, log_income_boxplot, cube_rt_delinq2yr_boxplot, cube_rt_bcOpen_boxplot, cube_rt_totalBcLim_boxplot, cube_rt_inq6mth_boxplot,  debtIncRat_boxplot, nrow=4, ncol=2, top="Predictors by Response", bottom = "Figure 2 Boxplots of Numeric Predictors by Response")
#https://stackoverflow.com/questions/17200114/how-to-split-data-into-training-testing-sets-using-sample-function
## 80% of the sample size
smp_size <- floor(0.8 * nrow(loans))
## set the seed to make your partition reproducible
set.seed(123)
train_ind <- sample(seq_len(nrow(loans)), size = smp_size)
train <- loans[train_ind, ]
test <- loans[-train_ind, ]
#cube_rt_delinq2yr +
loan.model <- glm(formula = response ~ log_amount + log_payment + log_income  + verified + debtIncRat + cube_rt_inq6mth + cube_rt_bcOpen + cube_rt_totalBcLim, family = "binomial", data = train)
extractAIC(loan.model)
summary(loan.model)
grid.arrange(log_amount_boxplot, log_payment_boxplot, log_income_boxplot, cube_rt_delinq2yr_boxplot, cube_rt_bcOpen_boxplot, cube_rt_totalBcLim_boxplot, cube_rt_inq6mth_boxplot,  debtIncRat_boxplot, nrow=4, ncol=2, top="Predictors by Response", bottom = "Figure 2 Boxplots of Numeric Predictors by Response",size="max")
grid.arrange(log_amount_boxplot, log_payment_boxplot, log_income_boxplot, cube_rt_delinq2yr_boxplot, cube_rt_bcOpen_boxplot, cube_rt_totalBcLim_boxplot, cube_rt_inq6mth_boxplot,  debtIncRat_boxplot,  top="Predictors by Response", bottom = "Figure 2 Boxplots of Numeric Predictors by Response",size="max")
grid.arrange(log_amount_boxplot, log_payment_boxplot, log_income_boxplot, cube_rt_delinq2yr_boxplot, cube_rt_bcOpen_boxplot, cube_rt_totalBcLim_boxplot, cube_rt_inq6mth_boxplot,  debtIncRat_boxplot, nrow=1, ncol=8, top="Predictors by Response", bottom = "Figure 2 Boxplots of Numeric Predictors by Response")
grid.arrange(log_amount_boxplot, log_payment_boxplot, log_income_boxplot, cube_rt_delinq2yr_boxplot, cube_rt_bcOpen_boxplot, cube_rt_totalBcLim_boxplot, cube_rt_inq6mth_boxplot,  debtIncRat_boxplot, nrow=8, ncol=1, top="Predictors by Response", bottom = "Figure 2 Boxplots of Numeric Predictors by Response")
grid.arrange(log_amount_boxplot, log_payment_boxplot, log_income_boxplot, cube_rt_delinq2yr_boxplot, cube_rt_bcOpen_boxplot, cube_rt_totalBcLim_boxplot, cube_rt_inq6mth_boxplot,  debtIncRat_boxplot, nrow=8, ncol=1, top="Predictors by Response", bottom = "Figure 2 Boxplots of Numeric Predictors by Response")
grid.arrange(log_amount_boxplot, log_payment_boxplot, log_income_boxplot, cube_rt_delinq2yr_boxplot, cube_rt_bcOpen_boxplot, cube_rt_totalBcLim_boxplot, cube_rt_inq6mth_boxplot,  debtIncRat_boxplot, nrow=4, ncol=2, top="Predictors by Response", bottom = "Figure 2 Boxplots of Numeric Predictors by Response")
log_amount_boxplot <- ggplot(aes(y = log_amount, x = response), data = loans) + geom_boxplot() + coord_flip()
grid.arrange(log_amount_boxplot, log_payment_boxplot, log_income_boxplot, cube_rt_delinq2yr_boxplot, cube_rt_bcOpen_boxplot, cube_rt_totalBcLim_boxplot, cube_rt_inq6mth_boxplot,  debtIncRat_boxplot, nrow=4, ncol=2, top="Predictors by Response", bottom = "Figure 2 Boxplots of Numeric Predictors by Response")
log_payment_boxplot <- ggplot(aes(y = log_payment, x = response), data = loans) + geom_boxplot() + coord_flip()
log_income_boxplot <- ggplot(aes(y = log_income, x = response), data = loans) + geom_boxplot() + coord_flip()
cube_rt_delinq2yr_boxplot <- ggplot(aes(y = cube_rt_delinq2yr, x = response), data = loans) + geom_boxplot() + coord_flip()
cube_rt_inq6mth_boxplot <- ggplot(aes(y = cube_rt_inq6mth, x = response), data = loans) + geom_boxplot() + coord_flip()
debtIncRat_boxplot <- ggplot(aes(y = debtIncRat, x = response), data = loans) + geom_boxplot() + coord_flip()
cube_rt_bcOpen_boxplot <- ggplot(aes(y = cube_rt_bcOpen, x = response), data = loans) + geom_boxplot() + coord_flip()
cube_rt_totalBcLim_boxplot <- ggplot(aes(y = cube_rt_totalBcLim, x = response), data = loans) + geom_boxplot() + coord_flip()
grid.arrange(log_amount_boxplot, log_payment_boxplot, log_income_boxplot, cube_rt_delinq2yr_boxplot, cube_rt_bcOpen_boxplot, cube_rt_totalBcLim_boxplot, cube_rt_inq6mth_boxplot,  debtIncRat_boxplot, nrow=4, ncol=2, top="Predictors by Response", bottom = "Figure 2 Boxplots of Numeric Predictors by Response")
log_amount_boxplot <- ggplot(aes(y = log_amount, x = response), data = loans) + geom_boxplot() + coord_flip() + theme(axis.title.y=element_blank(),axis.text.y=element_blank())
grid.arrange(log_amount_boxplot, log_payment_boxplot, log_income_boxplot, cube_rt_delinq2yr_boxplot, cube_rt_bcOpen_boxplot, cube_rt_totalBcLim_boxplot, cube_rt_inq6mth_boxplot,  debtIncRat_boxplot, nrow=4, ncol=2, top="Predictors by Response", bottom = "Figure 2 Boxplots of Numeric Predictors by Response")
log_amount_boxplot <- ggplot(aes(y = log_amount, x = response), data = loans) + geom_boxplot() + coord_flip() + theme(axis.title.y=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank())
grid.arrange(log_amount_boxplot, log_payment_boxplot, log_income_boxplot, cube_rt_delinq2yr_boxplot, cube_rt_bcOpen_boxplot, cube_rt_totalBcLim_boxplot, cube_rt_inq6mth_boxplot,  debtIncRat_boxplot, nrow=4, ncol=2, top="Predictors by Response", bottom = "Figure 2 Boxplots of Numeric Predictors by Response")
log_amount_boxplot <- ggplot(aes(y = log_amount, x = response), data = loans) + geom_boxplot() + coord_flip() + theme(axis.title.y=element_blank())
grid.arrange(log_amount_boxplot, log_payment_boxplot, log_income_boxplot, cube_rt_delinq2yr_boxplot, cube_rt_bcOpen_boxplot, cube_rt_totalBcLim_boxplot, cube_rt_inq6mth_boxplot,  debtIncRat_boxplot, nrow=4, ncol=2, top="Predictors by Response", bottom = "Figure 2 Boxplots of Numeric Predictors by Response")
log_payment_boxplot <- ggplot(aes(y = log_payment, x = response), data = loans) + geom_boxplot() + coord_flip() + theme(axis.title.y=element_blank())
log_income_boxplot <- ggplot(aes(y = log_income, x = response), data = loans) + geom_boxplot() + coord_flip() + theme(axis.title.y=element_blank())
cube_rt_delinq2yr_boxplot <- ggplot(aes(y = cube_rt_delinq2yr, x = response), data = loans) + geom_boxplot() + coord_flip() + theme(axis.title.y=element_blank())
cube_rt_inq6mth_boxplot <- ggplot(aes(y = cube_rt_inq6mth, x = response), data = loans) + geom_boxplot() + coord_flip() + theme(axis.title.y=element_blank())
debtIncRat_boxplot <- ggplot(aes(y = debtIncRat, x = response), data = loans) + geom_boxplot() + coord_flip() + theme(axis.title.y=element_blank())
cube_rt_bcOpen_boxplot <- ggplot(aes(y = cube_rt_bcOpen, x = response), data = loans) + geom_boxplot() + coord_flip() + theme(axis.title.y=element_blank())
cube_rt_totalBcLim_boxplot <- ggplot(aes(y = cube_rt_totalBcLim, x = response), data = loans) + geom_boxplot() + coord_flip() + theme(axis.title.y=element_blank())
grid.arrange(log_amount_boxplot, log_payment_boxplot, log_income_boxplot, cube_rt_delinq2yr_boxplot, cube_rt_bcOpen_boxplot, cube_rt_totalBcLim_boxplot, cube_rt_inq6mth_boxplot,  debtIncRat_boxplot, nrow=4, ncol=2, top="Predictors by Response", bottom = "Figure 2 Boxplots of Numeric Predictors by Response")
model.accuracy <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
predLoan <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
labels=c("Bad", "Good"))
cTab <- table(test$response, predLoan)
addmargins(cTab)
p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
}
threshholds <- seq(from = 0, to = 1, length.out = 30)
accuracy <- sapply(threshholds,model.accuracy)
accuracy.df <- data.frame(threshhold=threshholds, accuracy=accuracy)
#model is most accurate at around .5
plot(accuracy~threshholds)
View(accuracy.df)
# load dataset repair
require(DS705data)
data("repair")
# perform t-test to check whether mean repair time for mac and pc are significantly different.
mac.repair.time <- repair$time[which(repair$type=="Mac")]
pc.repair.time <- repair$time[which(repair$type=="PC")]
t.test(mac.repair.time, pc.repair.time, alternative = 'two.sided')$p.value
# Construct a 95% BCa confidence interval for the difference in population mean repair times.
library(boot)
bootMeanDiff <- function(d,i){
means <- tapply(d[i,1],d[,2],mean)
means[1]-means[2]
}
boot.object <- boot(repair, bootMeanDiff, R = 5000,
strata = repair$type)
boot.ci(boot.object,conf=.95,type='bca')$bca[4:5]
# two means bootstrap
xnull <- c(mac.repair.time-mean(mac.repair.time), pc.repair.time-mean(pc.repair.time))
g <- repair$type
rs <- rbind(replicate( 5000, sample( xnull[1:62], replace = T) ),
replicate( 5000, sample( xnull[63:122], replace = T) ) )
bootdist <- apply(rs, 2, function(c) t.test(c~g)$statistic )
bootdist <- apply(rs, 2, function(c) t.test(c~g)$statistic )
# compute observed test stat
toriginal <- t.test( repair$time~g)$statistic
# for asymmetric distributions the two-tailed P-value is
# ambiguous.  A common solution is to find smaller of the
# left and right tails and then double it.
P <- 2*min( sum( bootdist < toriginal), sum( bootdist > toriginal ) )/5000
P
View(repair)
hist( bootdist, probability = TRUE, breaks = 40, main = "",
xlab="",xlim=c(-4,4), ylim = c(0,.4))
hist(mac.repair.time)
hist(pc.repair.time)
require(DS705data)
data(shields)
library(ggplot2)
ggplot(aes(x = Machine, y = Diameter), data = shields) + geom_boxplot()
shields_box_plot <- ggplot(aes(x = Machine, y = Diameter), data = shields) + geom_boxplot()
shields_box_plot
resA <- shields$Diameter[shields$Machine=='A'] - mean(shields$Diameter[shields$Machine=='A'])
resB <- shields$Diameter[shields$Machine=='B'] - mean(shields$Diameter[shields$Machine=='B'])
resC <- shields$Diameter[shields$Machine=='C'] - mean(shields$Diameter[shields$Machine=='C'])
pop.null <- data.frame(res=c(resA,resB,resC),shields$Machine)
with(pop.null, tapply( res, shields$Machine, mean) )
B <- 10000; Fstar1 <- numeric(B)
for (i in 1:B){
pop.null <- data.frame(
res = sample( c(resA, resB, resC), replace = T), shields$Machine )
Fstar1[i] <- oneway.test( res~shields$Machine, data=pop.null,
var.equal=FALSE)$statistic
}
F.obs <- oneway.test( Diameter ~ Machine, data = shields)$statistic
Fstar1[is.na(Fstar1)] <- 100*F.obs
p.approx1 <- sum( Fstar1 > F.obs )/B; p.approx1
# use 10% trimmed means
t1waybt(Diameter~Machine,data=shields,tr=0.1,nboot=10000)
B <- 10000; Fstar2 <- numeric(B)
for (i in 1:B){
pop.null <- data.frame(
res = c( sample( resA, replace = T ),
sample( resB, replace = T ),
sample( resC, replace = T ) ), shields$Machine )
Fstar2[i] <- oneway.test( res~shields$Machine, data=pop.null,
var.equal=FALSE)$statistic
}
Fstar2[is.na(Fstar2)] <- 100*F.obs
p.approx2 <- sum( Fstar2 > F.obs )/B; p.approx2
install.packages("WRS2")
require('WRS2')  # install this package if needed
# use 10% trimmed means
t1waybt(Diameter~Machine,data=shields,tr=0.1,nboot=10000)
