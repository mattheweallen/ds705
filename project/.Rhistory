grid.arrange(log_amount_plot, log_payment_plot, nrow=1,
top="Movie Characteristics")
require(grid)
log_amount_plot <- ggplot(loans, aes(x=log_amount)) +
geom_histogram(binwidth=.1, colour="black", fill="white") + labs(x = "Log of Amount")
log_payment_plot <- ggplot(loans, aes(x=log_payment)) +
geom_histogram(binwidth=.1, colour="black", fill="white") + labs(x = "Log of Payment")
grid.arrange(log_amount_plot, log_payment_plot, nrow=1,
top="Movie Characteristics")
ggplot(aes(y = log_amount, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = amount, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = payment, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = log_payment, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = income, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = log_income, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = sqrt_openAcc, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = openAcc, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = sqrt_totalIlLim, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = totalIlLim, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = cube_rt_totalBal, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = log_amount, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = log_payment, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = sqrt_openAcc, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = cube_rt_totalBal, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = sqrt_totalIlLim, x = response), data = loans) + geom_boxplot()
# Get data
require(DS705data)
data("normtemp")
# Remove Missing Values
normtemp <- na.omit(normtemp)
loess_line <- loess(hr~temp,normtemp)
{
# Create Scatter Plot
plot(normtemp$hr~normtemp$temp, xlab ="Body Temperature (F)", ylab = "Heart Rate (bpm)")
lines(predict(loess_line), col='red', lwd=2)
}
# Obtain estimated slope and y-intercept.
linear.heartratetemp.model<-with(normtemp,lm(hr~temp))
linear.heartratetemp.model
# Summary of linear model
summary(linear.heartratetemp.model)
# 95% confidence interval of rate of change heart rate for 1 degree change in temperature
confint(linear.heartratetemp.model)
# Compute confidence interval
temp_df <- data.frame( temp = 98.6 )
predict(linear.heartratetemp.model, temp_df , interval="confidence")
# Compute prediction interval
temp_df <- data.frame( temp = 98.6 )
predict(linear.heartratetemp.model, temp_df, interval="prediction")
# Add plotting libraries
require(ggplot2)
require(qqplotr)
require(grid)
require(gridExtra)
# Plot resids~pred, resids~temp, resids hist, resids normal prob, and box plot. Perform a Shapiro-Wilk test.
resids <- linear.heartratetemp.model$resid # extract residuals from model
temp <- normtemp$temp #temperature values
fit <- linear.heartratetemp.model$fitted.values #fitted values
resids_df <- data.frame(residuals = resids, pred = fit, temp = temp)
resids_pred <- ggplot(resids_df,aes(x=pred, y=residuals)) + geom_point()
resids_pred
#shapiro-wilk test for normality
shapiro.test(resids)
#shapiro-wilk test for normality
mean(resids)
resids_pred <- ggplot(resids_df,aes(x=pred, y=residuals)) + geom_point() + geom_hline(yintercept = 0)
resids_pred
# Plot resids~pred, resids~temp, resids hist, resids normal prob, and box plot. Perform a Shapiro-Wilk test.
resids <- linear.heartratetemp.model$resid # extract residuals from model
temp <- normtemp$temp #temperature values
fit <- linear.heartratetemp.model$fitted.values #fitted values
resids_df <- data.frame(residuals = resids, pred = fit, temp = temp)
#resids_pred <- ggplot(resids_df,aes(x=pred, y=residuals)) + geom_point()
resids_temp <- ggplot(resids_df,aes(x=temp, y=residuals)) + geom_point()
resids_temp
#https://cran.r-project.org/web/packages/qqplotr/vignettes/introduction.html
resid_normal_qq <- ggplot(data = resids_df, mapping = aes(sample = residuals)) +
stat_qq_band() +
stat_qq_line() +
stat_qq_point() +
labs(x = "Theoretical Quantiles", y = "Sample Quantiles") +
ggtitle("Normal Q-Q Plot")
resid_normal_qq
#https://cran.r-project.org/web/packages/qqplotr/vignettes/introduction.html
resid_normal_qq <- ggplot(data = resids_df, mapping = aes(sample = residuals)) +
stat_qq_band() +
stat_qq_line() +
stat_qq_point() +
labs(x = "Theoretical Quantiles", y = "Sample Quantiles") +
ggtitle("Normal Q-Q Plot")
# Add plotting libraries
require(ggplot2)
require(qqplotr)
install.packages("qqplotr")
require(qqplotr)
require(grid)
require(gridExtra)
#https://cran.r-project.org/web/packages/qqplotr/vignettes/introduction.html
resid_normal_qq <- ggplot(data = resids_df, mapping = aes(sample = residuals)) +
stat_qq_band() +
stat_qq_line() +
stat_qq_point() +
labs(x = "Theoretical Quantiles", y = "Sample Quantiles") +
ggtitle("Normal Q-Q Plot")
install.packages("ggplot2")
install.packages("qqplotr")
# Get data
require(DS705data)
data("normtemp")
# Remove Missing Values
normtemp <- na.omit(normtemp)
loess_line <- loess(hr~temp,normtemp)
{
# Create Scatter Plot
plot(normtemp$hr~normtemp$temp, xlab ="Body Temperature (F)", ylab = "Heart Rate (bpm)")
lines(predict(loess_line), col='red', lwd=2)
}
# Obtain estimated slope and y-intercept.
linear.heartratetemp.model<-with(normtemp,lm(hr~temp))
linear.heartratetemp.model
# Summary of linear model
summary(linear.heartratetemp.model)
# 95% confidence interval of rate of change heart rate for 1 degree change in temperature
confint(linear.heartratetemp.model)
# Compute confidence interval
temp_df <- data.frame( temp = 98.6 )
predict(linear.heartratetemp.model, temp_df , interval="confidence")
# Compute prediction interval
temp_df <- data.frame( temp = 98.6 )
predict(linear.heartratetemp.model, temp_df, interval="prediction")
# Add plotting libraries
require(ggplot2)
require(qqplotr)
require(grid)
require(gridExtra)
# Plot resids~pred, resids~temp, resids hist, resids normal prob, and box plot. Perform a Shapiro-Wilk test.
resids <- linear.heartratetemp.model$resid # extract residuals from model
temp <- normtemp$temp #temperature values
fit <- linear.heartratetemp.model$fitted.values #fitted values
resids_df <- data.frame(residuals = resids, pred = fit, temp = temp)
resids_pred <- ggplot(resids_df,aes(x=pred, y=residuals)) + geom_point() + geom_hline(yintercept = 0)
resids_pred
#resids_pred <- ggplot(resids_df,aes(x=pred, y=residuals)) + geom_point()
resids_temp <- ggplot(resids_df,aes(x=temp, y=residuals)) + geom_point()
resids_temp
#https://cran.r-project.org/web/packages/qqplotr/vignettes/introduction.html
resid_normal_qq <- ggplot(data = resids_df, mapping = aes(sample = residuals)) +
stat_qq_band() +
stat_qq_line() +
stat_qq_point() +
labs(x = "Theoretical Quantiles", y = "Sample Quantiles") +
ggtitle("Normal Q-Q Plot")
resid_normal_qq
resids_boxplot <- ggplot(aes(y = residuals), data = resids_df) + geom_boxplot() +
theme(axis.title.x=element_blank(),axis.text.x=element_blank(),axis.ticks.x=element_blank())
resids_hist <- ggplot(data=resids_df, aes(residuals)) + geom_histogram(breaks=seq(-15, 15, by=1))
grid.arrange(resids_boxplot, resids_hist,nrow=1, ncol=2)
#shapiro-wilk test for normality
shapiro.test(resids)
#Check that the mean of the residuals is 0.
mean(resids)
knitr::opts_chunk$set(echo = FALSE)
require(ggplot2)
require(grid)
require(gridExtra)
filePath <- "C:/Users/matt/source/repos/ds705/project/loans50k.csv"
#filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
loans <- read.csv2(filePath, header = TRUE, sep = ",")
loans$response <- loans$status
#Good loans are those that have a status of "Fully Paid". Bad loans are those that have a status of "Charged Off" or "Default".
levels(loans$response)[levels(loans$response)==c("Charged Off")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Default")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Fully Paid")] <- "Good"
loans <- loans[which(loans$response=="Bad" | loans$response=="Good"), ]
#remove unuused levels
loans$response <- factor(loans$response)
summarize(loans)
summary(loans)
View(loans)
#eliminate length, many missing values what is another a proxy? show count of n/a.
table(loans$length)
class(loans$length)
#1823 as n/a
length(which(loans$length == "n/a"))
columns_to_keep <- c("response","amount","payment","home","income","openAcc","totalBal","totalLim","delinq2yr","inq6mth", "verified", "reason", "state")
loans <- loans[columns_to_keep]
#convert income and payment to numeric
loans$income <- as.numeric(as.character(loans$income))
loans$payment <- as.numeric(as.character(loans$payment))
loan.model <- glm(formula = response ~ log_amount + log_payment + log_income + sqrt_openAcc + cube_rt_totalBal + cube_rt_totalLim + verified + reason + state, family = "binomial", data = train)
#https://stackoverflow.com/questions/17200114/how-to-split-data-into-training-testing-sets-using-sample-function
## 80% of the sample size
smp_size <- floor(0.8 * nrow(loans))
## set the seed to make your partition reproducible
set.seed(123)
train_ind <- sample(seq_len(nrow(loans)), size = smp_size)
train <- loans[train_ind, ]
test <- loans[-train_ind, ]
loan.model <- glm(formula = response ~ log_amount + log_payment + log_income + sqrt_openAcc + cube_rt_totalBal + cube_rt_totalLim + verified + reason + state, family = "binomial", data = train)
#"response","amount","payment","home","income", "openAcc","totalBal","totalLim"
#transform variables
loans$log_amount <- log(loans$amount)
loans$log_payment <- log(loans$payment)
loans$log_income <- log(loans$income)
loans$sqrt_openAcc <- sqrt(loans$openAcc)
loans$cube_rt_totalBal <- (loans$totalBal)^(1/3)
loans$cube_rt_totalLim <- (loans$totalLim)^(1/3)
loan.model <- glm(formula = response ~ log_amount + log_payment + log_income + sqrt_openAcc + cube_rt_totalBal + cube_rt_totalLim + verified + reason + state, family = "binomial", data = train)
#"response","amount","payment","home","income", "openAcc","totalBal","totalLim"
#transform variables
loans$log_amount <- log(loans$amount)
loan.model <- glm(formula = response ~ log_amount + log_payment + log_income + sqrt_openAcc + cube_rt_totalBal + cube_rt_totalLim + verified + reason + state, family = "binomial", data = train)
View(train)
#https://stackoverflow.com/questions/17200114/how-to-split-data-into-training-testing-sets-using-sample-function
## 80% of the sample size
smp_size <- floor(0.8 * nrow(loans))
## set the seed to make your partition reproducible
set.seed(123)
train_ind <- sample(seq_len(nrow(loans)), size = smp_size)
train <- loans[train_ind, ]
test <- loans[-train_ind, ]
loan.model <- glm(formula = response ~ log_amount + log_payment + log_income + sqrt_openAcc + cube_rt_totalBal + cube_rt_totalLim + verified + reason + state, family = "binomial", data = train)
#predprob <- fitted(loan.model) # get predicted probabilities
predprob <- predict(loan.model, test, type="response")
threshhold <- 0.5  # Set Y=1 when predicted probability exceeds this
predRICH <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
labels=c("Sp Rich<4", "Sp Rich>=4"))  # Y=1 is "Sp Rich>=4" here
cTab <- table(test$response, predRICH)
addmargins(cTab)
p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
print(paste('Proportion correctly predicted = ', p))
threshholds <- seq(from = 0, to = 1, length.out = 100)
threshholds
accuracy <- sapply(threshholds,model.accuracy)
#predprob <- fitted(loan.model) # get predicted probabilities
model.accuracy <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
threshhold <- 0.5  # Set Y=1 when predicted probability exceeds this
predRICH <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
labels=c("Sp Rich<4", "Sp Rich>=4"))  # Y=1 is "Sp Rich>=4" here
cTab <- table(test$response, predRICH)
addmargins(cTab)
p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
}
accuracy <- sapply(threshholds,model.accuracy)
accuracy
#predprob <- fitted(loan.model) # get predicted probabilities
model.accuracy <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
#threshhold <- 0.5  # Set Y=1 when predicted probability exceeds this
predRICH <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
labels=c("Sp Rich<4", "Sp Rich>=4"))  # Y=1 is "Sp Rich>=4" here
cTab <- table(test$response, predRICH)
addmargins(cTab)
p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
}
accuracy <- sapply(threshholds,model.accuracy)
accuracy
threshholds <- seq(from = 0, to = 1, length.out = 50)
accuracy <- sapply(threshholds,model.accuracy)
accuracy
threshholds <- seq(from = 0, to = 1, length.out = 30)
accuracy <- sapply(threshholds,model.accuracy)
accuracy
plot(accuracy~threshholds)
View(train)
View(loans)
filePath <- "C:/Users/matt/source/repos/ds705/project/loans50k.csv"
#filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
loans <- read.csv2(filePath, header = TRUE, sep = ",")
loans$response <- loans$status
#Good loans are those that have a status of "Fully Paid". Bad loans are those that have a status of "Charged Off" or "Default".
levels(loans$response)[levels(loans$response)==c("Charged Off")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Default")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Fully Paid")] <- "Good"
loans <- loans[which(loans$response=="Bad" | loans$response=="Good"), ]
#remove unuused levels
loans$response <- factor(loans$response)
View(loans)
columns_to_keep <- c("response","totalPaid","amount","payment","home","income","openAcc","totalBal","totalLim","delinq2yr","inq6mth", "verified", "reason", "state")
loans <- loans[columns_to_keep]
View(loans)
#convert income and payment to numeric
loans$income <- as.numeric(as.character(loans$income))
loans$payment <- as.numeric(as.character(loans$payment))
#"response","amount","payment","home","income", "openAcc","totalBal","totalLim"
#transform variables
loans$log_amount <- log(loans$amount)
loans$log_payment <- log(loans$payment)
loans$log_income <- log(loans$income)
loans$sqrt_openAcc <- sqrt(loans$openAcc)
loans$cube_rt_totalBal <- (loans$totalBal)^(1/3)
loans$cube_rt_totalLim <- (loans$totalLim)^(1/3)
#https://stackoverflow.com/questions/17200114/how-to-split-data-into-training-testing-sets-using-sample-function
## 80% of the sample size
smp_size <- floor(0.8 * nrow(loans))
## set the seed to make your partition reproducible
set.seed(123)
train_ind <- sample(seq_len(nrow(loans)), size = smp_size)
train <- loans[train_ind, ]
test <- loans[-train_ind, ]
loan.model <- glm(formula = response ~ log_amount + log_payment + log_income + sqrt_openAcc + cube_rt_totalBal + cube_rt_totalLim + verified + reason + state, family = "binomial", data = train)
threshholds <- seq(from = 0, to = 1, length.out = 30)
View(test)
#predprob <- fitted(loan.model) # get predicted probabilities
model.profit <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
#threshhold <- 0.5  # Set Y=1 when predicted probability exceeds this
#predRICH <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
#                labels=c("Sp Rich<4", "Sp Rich>=4"))  # Y=1 is "Sp Rich>=4" here
#cTab <- table(test$response, predRICH)
#addmargins(cTab)
#p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
profit.df <- test[which(predprob > threshhold),c(test$totalPaid, test$amount)]
profit <- sum(profit.df$totalPaid - profit.df$amount)
}
threshholds <- seq(from = 0, to = 1, length.out = 30)
profit <- sapply(threshholds,model.profit)
#predprob <- fitted(loan.model) # get predicted probabilities
model.profit <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
predprob
#threshhold <- 0.5  # Set Y=1 when predicted probability exceeds this
#predRICH <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
#                labels=c("Sp Rich<4", "Sp Rich>=4"))  # Y=1 is "Sp Rich>=4" here
#cTab <- table(test$response, predRICH)
#addmargins(cTab)
#p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
profit.df <- test[which(predprob > threshhold),c(test$totalPaid, test$amount)]
profit <- sum(profit.df$totalPaid - profit.df$amount)
}
threshholds <- seq(from = 0, to = 1, length.out = 30)
profit <- sapply(threshholds,model.profit)
#predprob <- fitted(loan.model) # get predicted probabilities
model.profit <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
print(predprob)
#threshhold <- 0.5  # Set Y=1 when predicted probability exceeds this
#predRICH <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
#                labels=c("Sp Rich<4", "Sp Rich>=4"))  # Y=1 is "Sp Rich>=4" here
#cTab <- table(test$response, predRICH)
#addmargins(cTab)
#p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
profit.df <- test[which(predprob > threshhold),c(test$totalPaid, test$amount)]
profit <- sum(profit.df$totalPaid - profit.df$amount)
}
threshholds <- seq(from = 0, to = 1, length.out = 30)
profit <- sapply(threshholds,model.profit)
#predprob <- fitted(loan.model) # get predicted probabilities
model.profit <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
#print(predprob)
which(predprob > threshhold)
#threshhold <- 0.5  # Set Y=1 when predicted probability exceeds this
#predRICH <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
#                labels=c("Sp Rich<4", "Sp Rich>=4"))  # Y=1 is "Sp Rich>=4" here
#cTab <- table(test$response, predRICH)
#addmargins(cTab)
#p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
profit.df <- test[which(predprob > threshhold),c(test$totalPaid, test$amount)]
profit <- sum(profit.df$totalPaid - profit.df$amount)
}
threshholds <- seq(from = 0, to = 1, length.out = 30)
profit <- sapply(threshholds,model.profit)
#predprob <- fitted(loan.model) # get predicted probabilities
model.profit <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
#print(predprob)
print(which(predprob > threshhold))
#threshhold <- 0.5  # Set Y=1 when predicted probability exceeds this
#predRICH <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
#                labels=c("Sp Rich<4", "Sp Rich>=4"))  # Y=1 is "Sp Rich>=4" here
#cTab <- table(test$response, predRICH)
#addmargins(cTab)
#p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
profit.df <- test[which(predprob > threshhold),c(test$totalPaid, test$amount)]
profit <- sum(profit.df$totalPaid - profit.df$amount)
}
threshholds <- seq(from = 0, to = 1, length.out = 30)
profit <- sapply(threshholds,model.profit)
#predprob <- fitted(loan.model) # get predicted probabilities
model.profit <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
#print(predprob)
#print(which(predprob > threshhold))
#threshhold <- 0.5  # Set Y=1 when predicted probability exceeds this
#predRICH <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
#                labels=c("Sp Rich<4", "Sp Rich>=4"))  # Y=1 is "Sp Rich>=4" here
#cTab <- table(test$response, predRICH)
#addmargins(cTab)
#p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
profit.df <- test[which(predprob > threshhold),c("totalPaid", "amount")]
profit <- sum(profit.df$totalPaid - profit.df$amount)
}
threshholds <- seq(from = 0, to = 1, length.out = 30)
profit <- sapply(threshholds,model.profit)
profit
#predprob <- fitted(loan.model) # get predicted probabilities
model.profit <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
#print(predprob)
#print(which(predprob > threshhold))
#threshhold <- 0.5  # Set Y=1 when predicted probability exceeds this
#predRICH <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
#                labels=c("Sp Rich<4", "Sp Rich>=4"))  # Y=1 is "Sp Rich>=4" here
#cTab <- table(test$response, predRICH)
#addmargins(cTab)
#p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
profit.df <- test[which(predprob > threshhold),]
profit <- sum(profit.df$totalPaid - profit.df$amount)
}
threshholds <- seq(from = 0, to = 1, length.out = 30)
profit <- sapply(threshholds,model.profit)
#predprob <- fitted(loan.model) # get predicted probabilities
model.profit <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
#print(predprob)
#print(which(predprob > threshhold))
#threshhold <- 0.5  # Set Y=1 when predicted probability exceeds this
#predRICH <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
#                labels=c("Sp Rich<4", "Sp Rich>=4"))  # Y=1 is "Sp Rich>=4" here
#cTab <- table(test$response, predRICH)
#addmargins(cTab)
#p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
profit.df <- test[which(predprob > threshhold),]
profit <- sum(profit.df$totalPaid - profit.df$amount)
print(profit)
}
threshholds <- seq(from = 0, to = 1, length.out = 30)
profit <- sapply(threshholds,model.profit)
#predprob <- fitted(loan.model) # get predicted probabilities
summary(amount)
#predprob <- fitted(loan.model) # get predicted probabilities
summary(test$amount)
summary(test$totalPaid)
filePath <- "C:/Users/matt/source/repos/ds705/project/loans50k.csv"
#filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
loans <- read.csv2(filePath, header = TRUE, sep = ",")
#filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
loans <- read.csv2(filePath, header = TRUE, sep = ",")
loans$response <- loans$status
loans$response <- loans$status
#Good loans are those that have a status of "Fully Paid". Bad loans are those that have a status of "Charged Off" or "Default".
levels(loans$response)[levels(loans$response)==c("Charged Off")] <- "Bad"
#Good loans are those that have a status of "Fully Paid". Bad loans are those that have a status of "Charged Off" or "Default".
levels(loans$response)[levels(loans$response)==c("Charged Off")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Default")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Fully Paid")] <- "Good"
loans <- loans[which(loans$response=="Bad" | loans$response=="Good"), ]
#remove unuused levels
loans$response <- factor(loans$response)
#eliminate length, many missing values what is another a proxy? show count of n/a.
table(loans$length)
class(loans$length)
#1823 as n/a
length(which(loans$length == "n/a"))
columns_to_keep <- c("response","totalPaid","amount","payment","home","income","openAcc","totalBal","totalLim","delinq2yr","inq6mth", "verified", "reason", "state")
loans <- loans[columns_to_keep]
loans$totalPaid <- as.numeric(as.character(loans$totalPaid))
#convert income, payment and totalPaid to numeric
loans$income <- as.numeric(as.character(loans$income))
loans$payment <- as.numeric(as.character(loans$payment))
#"response","amount","payment","home","income", "openAcc","totalBal","totalLim"
#transform variables
loans$log_amount <- log(loans$amount)
loans$log_payment <- log(loans$payment)
loans$log_income <- log(loans$income)
loans$sqrt_openAcc <- sqrt(loans$openAcc)
loans$cube_rt_totalBal <- (loans$totalBal)^(1/3)
loans$cube_rt_totalLim <- (loans$totalLim)^(1/3)
#https://stackoverflow.com/questions/17200114/how-to-split-data-into-training-testing-sets-using-sample-function
## 80% of the sample size
smp_size <- floor(0.8 * nrow(loans))
## set the seed to make your partition reproducible
set.seed(123)
train_ind <- sample(seq_len(nrow(loans)), size = smp_size)
train <- loans[train_ind, ]
test <- loans[-train_ind, ]
loan.model <- glm(formula = response ~ log_amount + log_payment + log_income + sqrt_openAcc + cube_rt_totalBal + cube_rt_totalLim + verified + reason + state, family = "binomial", data = train)
#predprob <- fitted(loan.model) # get predicted probabilities
#summary(test$amount)
#summary(test$totalPaid)
model.profit <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
#print(predprob)
#print(which(predprob > threshhold))
#threshhold <- 0.5  # Set Y=1 when predicted probability exceeds this
#predRICH <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
#                labels=c("Sp Rich<4", "Sp Rich>=4"))  # Y=1 is "Sp Rich>=4" here
#cTab <- table(test$response, predRICH)
#addmargins(cTab)
#p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
profit.df <- test[which(predprob > threshhold),]
profit <- sum(profit.df$totalPaid - profit.df$amount)
#print(profit)
}
threshholds <- seq(from = 0, to = 1, length.out = 30)
profit <- sapply(threshholds,model.profit)
profit
plot(profit~threshholds)
summary(loans)
loan.model
summary(loan.model)
loan.model <- glm(formula = response ~ log_amount + log_payment + log_income + sqrt_openAcc + cube_rt_totalBal + cube_rt_totalLim + verified + reason + state + home, family = "binomial", data = train)
summary(loan.model)
summary(test$home)
summary(test)
filePath <- "C:/Users/matt/source/repos/ds705/project/loans50k.csv"
#filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
loans <- read.csv2(filePath, header = TRUE, sep = ",")
#Good loans are those that have a status of "Fully Paid". Bad loans are those that have a status of "Charged Off" or "Default".
levels(loans$response)[levels(loans$response)==c("Charged Off")] <- "Bad"
