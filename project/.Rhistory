#transform Source Verified to Verified
levels(loans$verified)[levels(loans$verified)==c("Source Verified")] <- "Verified"
#remove unuused levels
loans$verified <- factor(loans$verified)
#eliminate length, many missing values what is another a proxy? show count of n/a.
table(loans$length)
class(loans$length)
#1823 as n/a
length(which(loans$length == "n/a"))
columns_to_keep <- c("response","totalPaid", "amount", "debtIncRat","verified","income", "delinq2yr","inq6mth","payment", "bcOpen", "totalBcLim")
loans <- loans[columns_to_keep]
#convert income, amount, debtIncRat and totalPaid to numeric
loans$income <- as.numeric(as.character(loans$income))
loans$amount <- as.numeric(as.character(loans$amount))
loans$payment <- as.numeric(as.character(loans$payment))
loans$totalPaid <- as.numeric(as.character(loans$totalPaid))
loans$debtIncRat <- as.numeric(as.character(loans$debtIncRat))
#transform variables
loans$log_amount <- log(loans$amount)
loans$log_payment <- log(loans$payment)
loans$log_income <- log(loans$income)
#remove NAs from bcOpen, there are 360.
loans <- loans[which(is.na(!loans$bcOpen)),]
#replaced totalLim and totalBal etc with
loans$log_bcOpen <- log(loans$bcOpen)
loans$log_totalBcLim <- log(loans$totalBcLim)
loans$cube_rt_delinq2yr <- (loans$delinq2yr)^(1/3)
loans$cube_rt_inq6mth <- (loans$inq6mth)^(1/3)
#remove NAs from bcOpen, there are 360.
loans <- loans[which(!is.na(loans$bcOpen)),]
filePath <- "C:/Users/matt/source/repos/ds705/project/loans50k.csv"
#filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
loans <- read.csv2(filePath, header = TRUE, sep = ",")
#filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
loans <- read.csv2(filePath, header = TRUE, sep = ",")
loans$response <- loans$status
loans$response <- loans$status
#Good loans are those that have a status of "Fully Paid". Bad loans are those that have a status of "Charged Off" or "Default".
levels(loans$response)[levels(loans$response)==c("Charged Off")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Default")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Fully Paid")] <- "Good"
loans <- loans[which(loans$response=="Bad" | loans$response=="Good"), ]
#remove unuused levels
loans$response <- factor(loans$response)
#transform Source Verified to Verified
levels(loans$verified)[levels(loans$verified)==c("Source Verified")] <- "Verified"
#remove unuused levels
loans$verified <- factor(loans$verified)
#experiment
summary(loans$bcOpen)
hist(log(loans$bcOpen))
summary(loans$totalBcLim)
hist(log(loans$totalBcLim))
#eliminate length, many missing values what is another a proxy? show count of n/a.
table(loans$length)
class(loans$length)
#1823 as n/a
length(which(loans$length == "n/a"))
columns_to_keep <- c("response","totalPaid", "amount", "debtIncRat","verified","income", "delinq2yr","inq6mth","payment", "bcOpen", "totalBcLim")
loans <- loans[columns_to_keep]
#convert income, amount, debtIncRat and totalPaid to numeric
loans$income <- as.numeric(as.character(loans$income))
loans$amount <- as.numeric(as.character(loans$amount))
loans$payment <- as.numeric(as.character(loans$payment))
loans$totalPaid <- as.numeric(as.character(loans$totalPaid))
loans$debtIncRat <- as.numeric(as.character(loans$debtIncRat))
#transform variables
loans$log_amount <- log(loans$amount)
loans$log_payment <- log(loans$payment)
loans$log_income <- log(loans$income)
#remove NAs from bcOpen, there are 360.
loans <- loans[which(!is.na(loans$bcOpen)),]
#replaced totalLim and totalBal etc with
loans$log_bcOpen <- log(loans$bcOpen)
loans$log_totalBcLim <- log(loans$totalBcLim)
loans$cube_rt_delinq2yr <- (loans$delinq2yr)^(1/3)
loans$cube_rt_inq6mth <- (loans$inq6mth)^(1/3)
log_amount_plot <- ggplot(loans, aes(x=log_amount)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
#https://stackoverflow.com/questions/17200114/how-to-split-data-into-training-testing-sets-using-sample-function
## 80% of the sample size
smp_size <- floor(0.8 * nrow(loans))
## set the seed to make your partition reproducible
set.seed(123)
train_ind <- sample(seq_len(nrow(loans)), size = smp_size)
train <- loans[train_ind, ]
test <- loans[-train_ind, ]
#cube_rt_delinq2yr +
loan.model <- glm(formula = response ~ log_amount + log_income + log_payment + verified + debtIncRat + cube_rt_inq6mth + log_bcOpen + log_totalBcLim, family = "binomial", data = train)
#experiment
summary(loans$bcOpen)
hist((loans$bcOpen)^(1/3))
summary(loans$totalBcLim)
hist((loans$totalBcLim)^(1/3))
#replaced totalLim and totalBal etc with
loans$cube_rt_bcOpen <- log(loans$bcOpen)^(1/3)
loans$cube_rt_totalBcLim <- log(loans$totalBcLim)^(1/3)
#cube_rt_delinq2yr +
loan.model <- glm(formula = response ~ log_amount + log_income + log_payment + verified + debtIncRat + cube_rt_inq6mth + cube_rt_bcOpen+cube_rt_totalBcLim, family = "binomial", data = train)
#replaced totalLim and totalBal etc with
loans$cube_rt_bcOpen <- log(loans$bcOpen)^(1/3)
loans$cube_rt_totalBcLim <- log(loans$totalBcLim)^(1/3)
#cube_rt_delinq2yr +
loan.model <- glm(formula = response ~ log_amount + log_income + log_payment + verified + debtIncRat + cube_rt_inq6mth + cube_rt_bcOpen+cube_rt_totalBcLim, family = "binomial", data = train)
#https://stackoverflow.com/questions/17200114/how-to-split-data-into-training-testing-sets-using-sample-function
## 80% of the sample size
smp_size <- floor(0.8 * nrow(loans))
## set the seed to make your partition reproducible
set.seed(123)
train_ind <- sample(seq_len(nrow(loans)), size = smp_size)
train <- loans[train_ind, ]
test <- loans[-train_ind, ]
#cube_rt_delinq2yr +
loan.model <- glm(formula = response ~ log_amount + log_income + log_payment + verified + debtIncRat + cube_rt_inq6mth + cube_rt_bcOpen+cube_rt_totalBcLim, family = "binomial", data = train)
extractAIC(loan.model)
summary(loan.model)
summary(test)
require(HH)
vif(response ~ log_amount + log_income + debtIncRat + cube_rt_delinq2yr + cube_rt_inq6mth + payment,  data = train)
#predprob <- fitted(loan.model) # get predicted probabilities
predprob <- predict(loan.model, test, type="response")
threshhold <- 0.5  # Set Y=1 when predicted probability exceeds this
predLoan <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
labels=c("Bad", "Good"))
cTab <- table(test$response, predLoan)
addmargins(cTab)
p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
print(paste('Proportion correctly predicted = ', p))
model.accuracy <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
predLoan <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
labels=c("Bad", "Good"))
cTab <- table(test$response, predLoan)
addmargins(cTab)
p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
}
threshholds <- seq(from = 0, to = 1, length.out = 30)
accuracy <- sapply(threshholds,model.accuracy)
accuracy.df <- data.frame(threshhold=threshholds, accuracy=accuracy)
#model is same accuracy from 0 to .5.
plot(accuracy~threshholds)
model.profit <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
profit.df <- test[which(predprob > threshhold),]
profit <- sum(profit.df$totalPaid - profit.df$amount)
}
threshholds <- seq(from = 0, to = 1, length.out = 30)
profit <- sapply(threshholds,model.profit)
threshholds[which.max(profit)] #threshold of max profit
plot(profit~threshholds)
#cube_rt_delinq2yr +
loan.model <- glm(formula = response ~ log_amount + log_income + log_payment + verified + debtIncRat + cube_rt_inq6mth + cube_rt_bcOpen:cube_rt_totalBcLim, family = "binomial", data = train)
extractAIC(loan.model)
summary(loan.model)
extractAIC(loan.model)
summary(loan.model)
require(HH)
vif(response ~ log_amount + log_income + debtIncRat + cube_rt_delinq2yr + cube_rt_inq6mth + payment,  data = train)
vif(response ~ log_amount + log_income + debtIncRat + cube_rt_delinq2yr + cube_rt_inq6mth + payment + cube_rt_bcOpen:cube_rt_totalBcLim,  data = train)
#predprob <- fitted(loan.model) # get predicted probabilities
predprob <- predict(loan.model, test, type="response")
threshhold <- 0.5  # Set Y=1 when predicted probability exceeds this
predLoan <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
labels=c("Bad", "Good"))
cTab <- table(test$response, predLoan)
addmargins(cTab)
p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
print(paste('Proportion correctly predicted = ', p))
#cube_rt_delinq2yr +
loan.model <- glm(formula = response ~ log_amount + log_income + log_payment + verified + debtIncRat + cube_rt_inq6mth + cube_rt_bcOpen + cube_rt_totalBcLim, family = "binomial", data = train)
extractAIC(loan.model)
vif(response ~ log_amount + log_income + log_payment + verified + debtIncRat + cube_rt_inq6mth + cube_rt_bcOpen + cube_rt_totalBcLim,  data = train)
#predprob <- fitted(loan.model) # get predicted probabilities
predprob <- predict(loan.model, test, type="response")
threshhold <- 0.5  # Set Y=1 when predicted probability exceeds this
predLoan <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
labels=c("Bad", "Good"))
cTab <- table(test$response, predLoan)
addmargins(cTab)
p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
print(paste('Proportion correctly predicted = ', p))
model.accuracy <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
predLoan <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
labels=c("Bad", "Good"))
cTab <- table(test$response, predLoan)
addmargins(cTab)
p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
}
threshholds <- seq(from = 0, to = 1, length.out = 30)
accuracy <- sapply(threshholds,model.accuracy)
accuracy.df <- data.frame(threshhold=threshholds, accuracy=accuracy)
View(accuracy.df)
View(accuracy.df)
#model is most accurate at around .5
plot(accuracy~threshholds)
hist((loans$bcOpen)^(1/3))
cube_rt_bcOpen_plot <- ggplot(loans, aes(x=cube_rt_bcOpen)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=1, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
log_amount_plot <- ggplot(loans, aes(x=log_amount)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
log_payment_plot <- ggplot(loans, aes(x=log_payment)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
log_income_plot <- ggplot(loans, aes(x=log_income)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
cube_rt_delinq2yr_plot <- ggplot(loans, aes(x=cube_rt_delinq2yr)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_inq6mth_plot <- ggplot(loans, aes(x=cube_rt_inq6mth)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_bcOpen_plot <- ggplot(loans, aes(x=cube_rt_bcOpen)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=1, colour="black", fill="white")
debtIncRat_plot <- ggplot(loans, aes(x=debtIncRat)) +
geom_histogram(binwidth=1, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
filePath <- "C:/Users/matt/source/repos/ds705/project/loans50k.csv"
#filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
loans <- read.csv2(filePath, header = TRUE, sep = ",")
loans$response <- loans$status
#Good loans are those that have a status of "Fully Paid". Bad loans are those that have a status of "Charged Off" or "Default".
levels(loans$response)[levels(loans$response)==c("Charged Off")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Default")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Fully Paid")] <- "Good"
loans <- loans[which(loans$response=="Bad" | loans$response=="Good"), ]
#remove unuused levels
loans$response <- factor(loans$response)
#transform Source Verified to Verified
levels(loans$verified)[levels(loans$verified)==c("Source Verified")] <- "Verified"
#remove unuused levels
loans$verified <- factor(loans$verified)
#experiment
summary(loans$bcOpen)
hist((loans$bcOpen)^(1/3))
summary(loans$totalBcLim)
hist((loans$totalBcLim)^(1/3))
#eliminate length, many missing values what is another a proxy? show count of n/a.
table(loans$length)
class(loans$length)
#1823 as n/a
length(which(loans$length == "n/a"))
columns_to_keep <- c("response","totalPaid", "amount", "debtIncRat","verified","income", "delinq2yr","inq6mth","payment", "bcOpen", "totalBcLim")
loans <- loans[columns_to_keep]
#convert income, amount, debtIncRat and totalPaid to numeric
loans$income <- as.numeric(as.character(loans$income))
loans$amount <- as.numeric(as.character(loans$amount))
loans$payment <- as.numeric(as.character(loans$payment))
loans$totalPaid <- as.numeric(as.character(loans$totalPaid))
loans$debtIncRat <- as.numeric(as.character(loans$debtIncRat))
#transform variables
loans$log_amount <- log(loans$amount)
loans$log_payment <- log(loans$payment)
loans$log_income <- log(loans$income)
#remove NAs from bcOpen, there are 360.
loans <- loans[which(!is.na(loans$bcOpen)),]
#replaced totalLim and totalBal etc with
loans$cube_rt_bcOpen <- log(loans$bcOpen)^(1/3)
loans$cube_rt_totalBcLim <- log(loans$totalBcLim)^(1/3)
loans$cube_rt_delinq2yr <- (loans$delinq2yr)^(1/3)
loans$cube_rt_inq6mth <- (loans$inq6mth)^(1/3)
log_amount_plot <- ggplot(loans, aes(x=log_amount)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
log_payment_plot <- ggplot(loans, aes(x=log_payment)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
log_income_plot <- ggplot(loans, aes(x=log_income)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
cube_rt_delinq2yr_plot <- ggplot(loans, aes(x=cube_rt_delinq2yr)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_inq6mth_plot <- ggplot(loans, aes(x=cube_rt_inq6mth)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_bcOpen_plot <- ggplot(loans, aes(x=cube_rt_bcOpen)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=1, colour="black", fill="white")
debtIncRat_plot <- ggplot(loans, aes(x=debtIncRat)) +
geom_histogram(binwidth=1, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
cube_rt_bcOpen_plot <- ggplot(loans, aes(x=cube_rt_bcOpen)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
debtIncRat_plot <- ggplot(loans, aes(x=debtIncRat)) +
geom_histogram(binwidth=1, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
cube_rt_bcOpen_plot <- ggplot(loans, aes(x=cube_rt_bcOpen)) +
geom_histogram(binwidth=.01, colour="black", fill="white")
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=.01, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
summary(loans$cube_rt_bcOpen)
summary(loans$bcOpen)
summary(loans$cube_rt_totalBcLim)
summary(loans$totalBcLim)
#replaced totalLim and totalBal etc with
loans$cube_rt_bcOpen <- (loans$bcOpen)^(1/3)
loans$cube_rt_totalBcLim <- (loans$totalBcLim)^(1/3)
summary(loans$cube_rt_bcOpen)
summary(loans$cube_rt_totalBcLim)
cube_rt_bcOpen_plot <- ggplot(loans, aes(x=cube_rt_bcOpen)) +
geom_histogram(binwidth=.01, colour="black", fill="white")
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=.01, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
cube_rt_bcOpen_plot <- ggplot(loans, aes(x=cube_rt_bcOpen)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
cube_rt_bcOpen_plot <- ggplot(loans, aes(x=cube_rt_bcOpen)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=1, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
summary(loans$bcOpen)
summary(loans$totalBcLim)
loans$cube_rt_totalBcLim <- log(loans$totalBcLim + 1)
summary(loans$cube_rt_totalBcLim)
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=1, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
filePath <- "C:/Users/matt/source/repos/ds705/project/loans50k.csv"
#filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
loans <- read.csv2(filePath, header = TRUE, sep = ",")
#Good loans are those that have a status of "Fully Paid". Bad loans are those that have a status of "Charged Off" or "Default".
levels(loans$response)[levels(loans$response)==c("Charged Off")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Default")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Fully Paid")] <- "Good"
loans <- loans[which(loans$response=="Bad" | loans$response=="Good"), ]
#remove unuused levels
loans$response <- factor(loans$response)
require(ggplot2)
require(grid)
require(gridExtra)
#filePath <- "C:/Users/matt/source/repos/ds705/project/loans50k.csv"
filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
loans <- read.csv2(filePath, header = TRUE, sep = ",")
filePath <- "C:/Users/matt/source/repos/ds705/project/loans50k.csv"
#filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
loans <- read.csv2(filePath, header = TRUE, sep = ",")
loans$response <- loans$status
#Good loans are those that have a status of "Fully Paid". Bad loans are those that have a status of "Charged Off" or "Default".
levels(loans$response)[levels(loans$response)==c("Charged Off")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Default")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Fully Paid")] <- "Good"
loans <- loans[which(loans$response=="Bad" | loans$response=="Good"), ]
#remove unuused levels
loans$response <- factor(loans$response)
#transform Source Verified to Verified
levels(loans$verified)[levels(loans$verified)==c("Source Verified")] <- "Verified"
#remove unuused levels
loans$verified <- factor(loans$verified)
#experiment
summary(loans$bcOpen)
hist((loans$bcOpen)^(1/3))
summary(loans$totalBcLim)
hist((loans$totalBcLim)^(1/3))
#eliminate length, many missing values what is another a proxy? show count of n/a.
table(loans$length)
class(loans$length)
#1823 as n/a
length(which(loans$length == "n/a"))
columns_to_keep <- c("response","totalPaid", "amount", "debtIncRat","verified","income", "delinq2yr","inq6mth","payment", "bcOpen", "totalBcLim")
loans <- loans[columns_to_keep]
#convert income, amount, debtIncRat and totalPaid to numeric
loans$income <- as.numeric(as.character(loans$income))
loans$amount <- as.numeric(as.character(loans$amount))
loans$payment <- as.numeric(as.character(loans$payment))
loans$totalPaid <- as.numeric(as.character(loans$totalPaid))
loans$debtIncRat <- as.numeric(as.character(loans$debtIncRat))
#transform variables
loans$log_amount <- log(loans$amount)
loans$log_payment <- log(loans$payment)
loans$log_income <- log(loans$income)
#remove NAs from bcOpen, there are 360.
loans <- loans[which(!is.na(loans$bcOpen)),]
#replaced totalLim and totalBal etc with
loans$cube_rt_bcOpen <- (loans$bcOpen)^(1/3)
summary(loans$cube_rt_bcOpen)
summary(loans$bcOpen)
loans$cube_rt_totalBcLim <- (loans$totalBcLim)^(1/3)
summary(loans$cube_rt_totalBcLim)
summary(loans$totalBcLim)
loans$cube_rt_delinq2yr <- (loans$delinq2yr)^(1/3)
loans$cube_rt_inq6mth <- (loans$inq6mth)^(1/3)
log_amount_plot <- ggplot(loans, aes(x=log_amount)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
log_payment_plot <- ggplot(loans, aes(x=log_payment)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
log_income_plot <- ggplot(loans, aes(x=log_income)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
cube_rt_delinq2yr_plot <- ggplot(loans, aes(x=cube_rt_delinq2yr)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_inq6mth_plot <- ggplot(loans, aes(x=cube_rt_inq6mth)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_bcOpen_plot <- ggplot(loans, aes(x=cube_rt_bcOpen)) +
geom_histogram(binwidth=1, colour="black", fill="white")
cube_rt_totalBcLim_plot <- ggplot(loans, aes(x=cube_rt_totalBcLim)) +
geom_histogram(binwidth=1, colour="black", fill="white")
debtIncRat_plot <- ggplot(loans, aes(x=debtIncRat)) +
geom_histogram(binwidth=1, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, log_income_plot,  cube_rt_delinq2yr_plot, cube_rt_inq6mth_plot, cube_rt_bcOpen_plot, cube_rt_totalBcLim_plot, debtIncRat_plot, nrow=4, ncol=2, top="Predictors", bottom = "Figure 1 Histograms of Numeric Predictors")
log_amount_boxplot <- ggplot(aes(y = log_amount, x = response), data = loans) + geom_boxplot() + coord_flip() + theme(axis.title.y=element_blank())
log_payment_boxplot <- ggplot(aes(y = log_payment, x = response), data = loans) + geom_boxplot() + coord_flip() + theme(axis.title.y=element_blank())
log_income_boxplot <- ggplot(aes(y = log_income, x = response), data = loans) + geom_boxplot() + coord_flip() + theme(axis.title.y=element_blank())
cube_rt_delinq2yr_boxplot <- ggplot(aes(y = cube_rt_delinq2yr, x = response), data = loans) + geom_boxplot() + coord_flip() + theme(axis.title.y=element_blank())
cube_rt_inq6mth_boxplot <- ggplot(aes(y = cube_rt_inq6mth, x = response), data = loans) + geom_boxplot() + coord_flip() + theme(axis.title.y=element_blank())
debtIncRat_boxplot <- ggplot(aes(y = debtIncRat, x = response), data = loans) + geom_boxplot() + coord_flip() + theme(axis.title.y=element_blank())
cube_rt_bcOpen_boxplot <- ggplot(aes(y = cube_rt_bcOpen, x = response), data = loans) + geom_boxplot() + coord_flip() + theme(axis.title.y=element_blank())
cube_rt_totalBcLim_boxplot <- ggplot(aes(y = cube_rt_totalBcLim, x = response), data = loans) + geom_boxplot() + coord_flip() + theme(axis.title.y=element_blank())
grid.arrange(log_amount_boxplot, log_payment_boxplot, log_income_boxplot, cube_rt_delinq2yr_boxplot, cube_rt_bcOpen_boxplot, cube_rt_totalBcLim_boxplot, cube_rt_inq6mth_boxplot,  debtIncRat_boxplot, nrow=4, ncol=2, top="Predictors by Response", bottom = "Figure 2 Boxplots of Numeric Predictors by Response")
#https://stackoverflow.com/questions/17200114/how-to-split-data-into-training-testing-sets-using-sample-function
## 80% of the sample size
smp_size <- floor(0.8 * nrow(loans))
## set the seed to make your partition reproducible
set.seed(123)
train_ind <- sample(seq_len(nrow(loans)), size = smp_size)
train <- loans[train_ind, ]
test <- loans[-train_ind, ]
#cube_rt_delinq2yr +
loan.model <- glm(formula = response ~ log_amount + log_payment + log_income  + verified + debtIncRat + cube_rt_inq6mth + cube_rt_bcOpen + cube_rt_totalBcLim, family = "binomial", data = train)
extractAIC(loan.model)
summary(loan.model)
require(HH)
vif(response ~ log_amount + log_payment + log_income  + verified + debtIncRat + cube_rt_inq6mth + cube_rt_bcOpen + cube_rt_totalBcLim,  data = train)
#predprob <- fitted(loan.model) # get predicted probabilities
predprob <- predict(loan.model, test, type="response")
threshhold <- 0.5  # Set Y=1 when predicted probability exceeds this
predLoan <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
labels=c("Bad", "Good"))
cTab <- table(test$response, predLoan)
addmargins(cTab)
p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
print(paste('Proportion correctly predicted = ', p))
model.accuracy <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
predLoan <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
labels=c("Bad", "Good"))
cTab <- table(test$response, predLoan)
addmargins(cTab)
p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
}
threshholds <- seq(from = 0, to = 1, length.out = 30)
accuracy <- sapply(threshholds,model.accuracy)
accuracy.df <- data.frame(threshhold=threshholds, accuracy=accuracy)
#model is most accurate at around .5
plot(accuracy~threshholds)
model.profit <- function(threshhold) {
predprob <- predict(loan.model, test, type="response")
profit.df <- test[which(predprob > threshhold),]
profit <- sum(profit.df$totalPaid - profit.df$amount)
}
threshholds <- seq(from = 0, to = 1, length.out = 30)
profit <- sapply(threshholds,model.profit)
max(profit)
threshholds[which.max(profit)] #threshold of max profit
View(accuracy.df)
threshhold.df(threshhold=threshholds, profit=profit)
threshhold.df <- data.frame(threshhold=threshholds, profit=profit)
View(threshhold.df)
#no loans denied
noloandenied.profit <- sum(test$totalPaid - test$amount)
noloandenied.profit
#increases
(max(profit) - noloandenied.profit)/noloandenied.profit
View(test)
#perfect prediction
good.test.df <- test[which(predict == "Good"),]
#perfect prediction
good.test.df <- test[which(test$predict == "Good"),]
sum(good.test.df$totalPaid - good.test.df$amount)
View(test)
#perfect prediction
good.test.df <- test[which(test$response == "Good"),]
sum(good.test.df$totalPaid - good.test.df$amount)
#perfect increase
(perfect.profit - noloandenied.profit)/noloandenied.profit
perfect.profit <- sum(good.test.df$totalPaid - good.test.df$amount)
#perfect increase
(perfect.profit - noloandenied.profit)/noloandenied.profit
1485/244
#predprob <- fitted(loan.model) # get predicted probabilities
predprob <- predict(loan.model, test, type="response")
threshhold <- 0.76  # Set Y=1 when predicted probability exceeds this
predLoan <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
labels=c("Bad", "Good"))
cTab <- table(test$response, predLoan)
addmargins(cTab)
p <- sum(diag(cTab)) / sum(cTab)  # compute the proportion of correct classifications
print(paste('Proportion correctly predicted = ', p))
addmargins(cTab)
#predprob <- fitted(loan.model) # get predicted probabilities
predprob <- predict(loan.model, test, type="response")
threshhold <- 0.76  # Set Y=1 when predicted probability exceeds this
predLoan <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
labels=c("Bad", "Good"))
cTab <- table(test$response, predLoan)
addmargins(cTab)
```{r contigency_table, include=FALSE}
#predprob <- fitted(loan.model) # get predicted probabilities
predprob <- predict(loan.model, test, type="response")
threshhold <- 0.76  # Set Y=1 when predicted probability exceeds this
predLoan <- cut(predprob, breaks=c(-Inf, threshhold, Inf),
labels=c("Bad", "Good"))
cTab <- table(test$response, predLoan)
addmargins(cTab)
print(paste('Proportion correctly predicted given bad loan = ', 819/1521))
print(paste('Proportion correctly predicted given good loan = ', 3626/5338))
print(paste('Proportion correctly predicted given bad loan = ', 819/1521))
print(paste('Proportion correctly predicted given good loan = ', 3626/5338))
