ts1 <- ts1[order(ts1$Year.month),]
ts1 <- data.frame(ts1)
ts1$linearTrend <- seq(along = ts1$Prod.Count)/12
#write.Alteryx(ts1,4)
values <- ts1[,c("claim.cnt","Prod.Count","active.cnt","expired.cnt","linearTrend")]
## It is working till here, continue to debug from here on##
myts <- ts(values,start=c(2013, 1), end=c(2017, 07), frequency=12)
temp <- (time(myts))
tms <- date_decimal(myts)
#write.Alteryx(data.frame(Y=as.matrix(myts),temp) ,5)
##***********###MODEL TO PREDICT PRODUCTION COUNT###************
##TRAIN MODEL ON 2013-2015 AND PREDICT ON 2016/2017###
#class(myts)
#tsp_y <- myts[, "Prod.Count"]
tsp_y <- myts
tspy1_1315 <- window(tsp_y, start = 2013, end = c(2015,12))
#Simple raw count prediction model, it doesn't take into updated production count
fitp1315 <- tscount::tsglm(tspy1_1315, model=list(past_obs = c(1, 12)), link = "log", distr = "poisson")####
plot(fitp1315)
#write.Alteryx(data.frame(fitp1315$n_obs),3)
tspy_1617 <- window(tsp_y, start = 2016, end = c(2017,07))
#write.Alteryx(data.frame(tspy_1617), 2)
#n.ahead was n.ahead=24 now we changed it to n.ahead=3
yp1617 <- predict(fitp1315,n.ahead = 19,level = 0.9, global = TRUE)$median
#write.Alteryx(data.frame(as.matrix(yp1617)),1)
#round(yp1617)
#Add a time column called index start at 2016 end 2017,07
##########################################################################
#model_matrix <- timetk::tk_tbl(yp1617)
model_matrix <- data.frame(as.matrix(yp1617))
colnames(model_matrix)<- "value"
model_matrix$index <- create_timeseries_index(2016, 1, 2017, 7)
#model_matrix <- data.frame(model_matrix)
### add predicted production count for year 2016/2017 and create a model to predict monthly claims
#month.abb is system generated constant
#add 0 to m_num if its 1 to 9 in order to match like ts1 data frame to join on Year.month
model_matrix <- model_matrix %>%
rename("month.year" = index,
"Pred.Prod" = value) %>%
mutate( month.year = as.character(month.year),
m_abr = substr(month.year,1,3),
m_num = match(m_abr, month.abb),
m_num = as.character(m_num),
m_num = ifelse(nchar(m_num)==1,paste0("0",m_num),m_num),
yr = substr(month.year,5,8),
Pred.Prod = round(Pred.Prod),
Year.month = paste(yr,m_num,sep="/"))
ts2 <- ts1 %>%
left_join(model_matrix, by = "Year.month") %>%
dplyr::select(Year.month,claim.cnt,Prod.Count,expired.cnt,active.cnt,linearTrend,Pred.Prod)
#copy of ts2 with NA values pred.prod for year 2013 to 2015
ts2$Pred.Prod <- ifelse(((ts2$Pred.Prod) < ts2$Prod.Count), ts2$Prod.Count,ts2$Pred.Prod)
model2 <- ts2
ts2$Pred.Prod <- ifelse(is.na(ts2$Pred.Prod),ts2$Prod.Count,ts2$Pred.Prod)
# plot actual vs. predicted Production count
model2 <- model2 %>%
dplyr::select(Year.month,Prod.Count,Pred.Prod) %>%
gather(key, value, Prod.Count, Pred.Prod)
#Model with one predictor using pred.prod (predicted prod) as explanatory variable
#train data 2013-2015 test 2016/2017
v2 <- ts2[,c("claim.cnt","Prod.Count","active.cnt","expired.cnt","linearTrend","Pred.Prod")]
myts2 <- ts(v2,start=c(2013, 1), end=c(2017, 12), frequency=12)
ts2_y <- myts2[, "claim.cnt"]
ts2_x <- cbind(Prod.Count = myts2[, c("Pred.Prod")])
ts2x_1315 <-  window(ts2_x, start = 2013, end = c(2015,12))
ts2y_1315 <- window(ts2_y, start = 2013, end = c(2015,12))
pclaimsfit1315 <- tsglm(ts2y_1315, model=list(past_obs = c(1, 12)), link = "log", distr = "poisson", xreg=ts2x_1315)
summary(pclaimsfit1315)
ts2x_1617 <- window(ts2_x, start = 2016, end = c(2017,12))
ts2y_1617 <- window(ts2_y, start = 2016, end = c(2017,12))
py1617 <- predict(pclaimsfit1315, n.ahead = 24, level = 0.9, global = TRUE, newxreg = ts2x_1617)$pred
round(py1617)
#prepare data set for gg plot
#md3 <- timetk::tk_tbl(py1617)
#md3 <- data.frame(md3)
md3 <- timeSeries::as.data.frame(py1617)
md3 <- md3 %>%
rename("month.year" = index,
"Pred.claim" = value) %>%
mutate( month.year = as.character(month.year),
m_abr = substr(month.year,1,3),
m_num = match(m_abr, month.abb),
m_num = as.character(m_num),
m_num = ifelse(nchar(m_num)==1,paste0("0",m_num),m_num),
yr = substr(month.year,5,8),
Pred.claim = round(Pred.claim),
Year.month = paste(yr,m_num,sep="/")) %>%
dplyr::select(Year.month,Pred.claim)
model3 <- ts2 %>%
left_join(md3, by = "Year.month") %>%
dplyr::select(Year.month,claim.cnt,Pred.claim)
model3 <- model3 %>%
gather(key, value, claim.cnt, Pred.claim)
}# End of part # (cof_level3) for loop
institution <- c("Bank", "Credit Union")
outstanding <- c(70,66)
not_outstanding <- c(150,81)
ratings <- matrix(c(outstanding, not_outstanding),ncol=2)
colnames(ratings) <- c("Outstanding","Not Outstanding")
rownames(ratings) <- institution
ratings_with_margins <- addmargins(as.table(ratings))
ratings_with_margins
# Construct 95% Confidence Interval for proportion of Credit Unions rated as Outstanding.
prop.test(ratings_with_margins["Credit Union","Outstanding"],ratings_with_margins["Credit Union","Sum"],correct = FALSE)$conf.int
# Insert your R code here.
prop.test(abs(ratings_with_margins["Credit Union","Outstanding"]-ratings_with_margins["Bank","Outstanding"]),abs(ratings_with_margins["Credit Union","Sum"]-ratings_with_margins["Bank","Sum"]),correct = FALSE)$conf.int
# what is the estimated risk of a bank not being rated as outstanding?
bank_risk_not_outstanding <- ratings_with_margins["Bank","Not Outstanding"]/ratings_with_margins["Bank","Sum"]
bank_risk_not_outstanding
# what is the estimated risk of a Credit not being rated as outstanding?
credit_union_risk_not_outstanding <- ratings_with_margins["Credit Union","Not Outstanding"]/ratings_with_margins["Credit Union","Sum"]
credit_union_risk_not_outstanding
# Relative risk banks not outstanding compared to credit unions
bank_risk_not_outstanding/credit_union_risk_not_outstanding
# Estimated odds of credit union being rated as outstanding
#calculate by manually
odds_credit_union_outstanding <- (1-credit_union_risk_not_outstanding)/credit_union_risk_not_outstanding
odds_credit_union_outstanding
#calculate with mosaic
require(mosaic)
#calculate with mosaic
require(mosaic)
oddsRatio(ratings,verbose = TRUE)
```{r echo=FALSE}
# Estimated odds of credit union being rated as outstanding
#calculate by manually
odds_credit_union_outstanding <- (1-credit_union_risk_not_outstanding)/credit_union_risk_not_outstanding
odds_credit_union_outstanding
#calculate with mosaic
require(mosaic)
oddsRatio(ratings,verbose = TRUE)
#manual calculation of bank being rated as outstanding
odds_bank_outstanding <- (1-bank_risk_not_outstanding)/bank_risk_not_outstanding
odds_bank_outstanding
# Compute the estimated odds ratio of being rated as outstanding for credit unions compared to banks.
odds_credit_union_outstanding/odds_bank_outstanding
# Run Chi Squared test
observed <- c(28,44,54,39)
proportions <- c(.13,.32,.38,.17)
chisq.test(x=observed,p=proportions)
# Compute expected cell counts
expected_counts <- sum(observed) * proportions
expected_counts
# Insert your R code here. MEALLEN mayb plot with expected_counts?
barplot(observed,names.arg=c("Under 18", "18 to 35", "36 to 50","Over 50"),
ylab="Count",col=c("purple","blue","red","green"), main = "Sample of Online Purchases by Age Group")
# Create contingency table from anesthesia data
require(DS705data)
data("anesthesia")
anesthetic_nausea <- with(anesthesia,table(anesthetic,nausea))
addmargins(anesthetic_nausea)
barplot(anesthetic_nausea,xlab="Region", ylab="Frequency",
col=c("khaki","cyan"),legend=rownames(anesthetic_nausea),beside=T)
# Insert your R code here.
#p 521
chisq.test(anesthetic_nausea, correct=FALSE)
# Create 2X2 matrix for seat belt data
age_group <- c("Teen", "Senior")
always_wear <- c(17,12)
not_always_wear <- c(2,8)
seat_belt_usage <- matrix(c(always_wear, not_always_wear),ncol=2,byrow = TRUE)
colnames(seat_belt_usage) <- age_group
rownames(seat_belt_usage) <- c("always_wear", "not_always_wear")
seat_belt_usage
# Insert your R code here.
#p.511-512 Fisher Exact Test
#fisher.test
fisher.test(seat_belt_usage,alternative="two.sided")
```{r results="hide" }
# Estimated odds of credit union being rated as outstanding
#calculate by manually
odds_credit_union_outstanding <- (1-credit_union_risk_not_outstanding)/credit_union_risk_not_outstanding
odds_credit_union_outstanding
#calculate with mosaic
require(mosaic)
oddsRatio(ratings,verbose = TRUE)
```{r include=FALSE}
# Estimated odds of credit union being rated as outstanding
#calculate by manually
odds_credit_union_outstanding <- (1-credit_union_risk_not_outstanding)/credit_union_risk_not_outstanding
odds_credit_union_outstanding
#calculate with mosaic
require(mosaic)
oddsRatio(ratings,verbose = TRUE)
knitr::opts_chunk$set(echo = TRUE)
#import data
loans <- read.csv2("C:/Users/matt/source/repos/ds705/project/loans50k.csv", header = TRUE, sep = ",")
#filePath <- "C:/Users/matt/source/repos/ds705/project/loans50k.csv"
filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
knitr::opts_chunk$set(echo = FALSE)
#filePath <- "C:/Users/matt/source/repos/ds705/project/loans50k.csv"
filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
loans <- read.csv2(filePath, header = TRUE, sep = ",")
loans$response <- loans$status
#Good loans are those that have a status of "Fully Paid". Bad loans are those that have a status of "Charged Off" or "Default".
table(loans$response)
levels(loans$response)[levels(loans$response)==c("Charged Off")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Default")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Fully Paid")] <- "Good"
loans <- loans[which(loans$response=="Bad" | loans$response=="Good"), ]
#remove unuused levels
loans$response <- factor(loans$response)
#loans <- loans[loans$response == c("Good","Bad"),]
table(loans$response)
columns_to_keep <- c("response","amount","payment","home","income","delinq2yr","inq6mth","openAcc","totalBal","totalIlLim")
loans <- loans[columns_to_keep]
summary(loans)
```{r create_response_column, include=FALSE}
#filePath <- "C:/Users/matt/source/repos/ds705/project/loans50k.csv"
filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
loans <- read.csv2(filePath, header = TRUE, sep = ",")
loans$response <- loans$status
#Good loans are those that have a status of "Fully Paid". Bad loans are those that have a status of "Charged Off" or "Default".
table(loans$response)
levels(loans$response)[levels(loans$response)==c("Charged Off")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Default")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Fully Paid")] <- "Good"
loans <- loans[which(loans$response=="Bad" | loans$response=="Good"), ]
#remove unuused levels
loans$response <- factor(loans$response)
#loans <- loans[loans$response == c("Good","Bad"),]
table(loans$response)
#eliminate length, many missing values what is another a proxy? show count of n/a.
table(loans$length)
class(loans$length)
#1823 as n/a
length(which(loans$length == "n/a"))
loans$length[NA]
columns_to_keep <- c("response","amount","payment","home","income","delinq2yr","inq6mth","openAcc","totalBal","totalIlLim")
loans <- loans[columns_to_keep]
#convert income and payment to numeric
loans$income <- as.numeric(as.character(loans$income))
loans$payment <- as.numeric(as.character(loans$payment))
#filePath <- "C:/Users/matt/source/repos/ds705/project/loans50k.csv"
filePath <- "C:/Users/irgepi/source/repos/ds705/project/loans50k.csv"
loans <- read.csv2(filePath, header = TRUE, sep = ",")
loans$response <- loans$status
#Good loans are those that have a status of "Fully Paid". Bad loans are those that have a status of "Charged Off" or "Default".
table(loans$response)
levels(loans$response)[levels(loans$response)==c("Charged Off")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Default")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Fully Paid")] <- "Good"
loans <- loans[which(loans$response=="Bad" | loans$response=="Good"), ]
#remove unuused levels
loans$response <- factor(loans$response)
#loans <- loans[loans$response == c("Good","Bad"),]
table(loans$response)
#eliminate length, many missing values what is another a proxy? show count of n/a.
table(loans$length)
class(loans$length)
#1823 as n/a
length(which(loans$length == "n/a"))
columns_to_keep <- c("response","amount","payment","home","income","openAcc","totalBal","totalIlLim") #,"delinq2yr","inq6mth" removed
loans <- loans[columns_to_keep]
#convert income and payment to numeric
loans$income <- as.numeric(as.character(loans$income))
loans$payment <- as.numeric(as.character(loans$payment))
#https://stats.stackexchange.com/questions/11406/boxplot-with-respect-to-two-factors-using-ggplot2-in-r
require(ggplot2)
ggplot(loans, aes(x=amount)) +
geom_histogram(binwidth=250, colour="black", fill="white")
ggplot(loans, aes(x=amount)) +
geom_histogram(binwidth=5, colour="black", fill="white")
ggplot(loans, aes(x=amount)) +
geom_histogram(binwidth=500, colour="black", fill="white")
hist(loans$amount)
hist(sqrt(loans$amount))
hist(loans$amount)
hist(log(loans$amount))
hist(loans$payment)
hist(log(loans$payment))
loans$log_payment <- log(loans$payment)
#hist(loans$delinq2yr) #do not transform does not appear to help,
#summary(loans$delinq2yr)
#hist(loans$inq6mth) #do not transform because not help
#summary(loans$inq6mth)
hist(loans$home)
#hist(loans$delinq2yr) #do not transform does not appear to help,
#summary(loans$delinq2yr)
#hist(loans$inq6mth) #do not transform because not help
#summary(loans$inq6mth)
boxplot(loans$home)
#hist(loans$delinq2yr) #do not transform does not appear to help,
#summary(loans$delinq2yr)
#hist(loans$inq6mth) #do not transform because not help
#summary(loans$inq6mth)
hist(sqrt(loans$openAcc))
loans$log_totalBal <- log(loans$totalBal)
loans$log_totalBal <- log(loans$totalBal)
loans$log_totalIlLim <- log(loans$totalIlLim)
hist(log(loans$log_amount))
class(loans$log_amount)
View(loans)
#"response","amount","payment","home","income", "openAcc","totalBal","totalIlLim"
#transform variables
loans$sqrt_amount <- sqrt(loans$amount)
hist(log(loans$sqrt_amount))
hist(loans$log_payment)
hist(log(loans$log_income))
loans$log_income <- log(loans$income)
loans$sqrt_income <- sqrt(loans$income)
hist(loans$log_income)
#"response","amount","payment","home","income", "openAcc","totalBal","totalIlLim"
#transform variables
loans$log_amount <- log(loans$amount)
hist(loans$log_amount)
summary(loans)
#hist(loans$delinq2yr) #do not transform does not appear to help,
#summary(loans$delinq2yr)
#hist(loans$inq6mth) #do not transform because not help
#summary(loans$inq6mth)
hist(loans$sqrt_openAcc)
loans$sqrt_openAcc <- sqrt(loans$openAcc)
loans$sqrt_totalBal <- sqrt(loans$totalBal)
loans$sqrt_totalIlLim <- sqrt(loans$totalIlLim)
#hist(loans$delinq2yr) #do not transform does not appear to help,
#summary(loans$delinq2yr)
#hist(loans$inq6mth) #do not transform because not help
#summary(loans$inq6mth)
hist(loans$sqrt_openAcc)
hist(loans$sqrt_totalBal)
hist(loans$sqrt_totalIlLim)
hist(loans$sqrt_totalBal)
loans$cube_rt_totalBal <- (loans$totalBal)^(1/3)
hist(loans$cube_rt_totalBal)
hist(loans$sqrt_totalIlLim)
loans$cube_rt_totalIlLim <- (loans$totalIlLim)^(1/3)
hist(loans$cube_rt_totalIlLim)
hist(loans$sqrt_totalIlLim)
ggplot(loans, aes(x=log_amount)) +
geom_histogram(binwidth=500, colour="black", fill="white")
ggplot(loans, aes(x=log_amount)) +
geom_histogram(binwidth=50, colour="black", fill="white")
hist(loans$amount)
hist(loans$log_amount)
ggplot(loans, aes(x=log_amount)) +
geom_histogram(binwidth=1, colour="black", fill="white")
ggplot(loans, aes(x=log_amount)) +
geom_histogram(binwidth=5, colour="black", fill="white")
ggplot(loans, aes(x=log_amount)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
require(gridExtra)
ggplot(loans, aes(x=log_payment)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
log_amount_plot <- ggplot(loans, aes(x=log_payment)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
require(grid)
log_amount_plot <- ggplot(loans, aes(x=log_amount)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
log_payment_plot <- ggplot(loans, aes(x=log_payment)) +
geom_histogram(binwidth=.1, colour="black", fill="white")
grid.arrange(log_amount_plot, log_payment_plot, nrow=1,
top="Movie Characteristics")
require(grid)
log_amount_plot <- ggplot(loans, aes(x=log_amount)) +
geom_histogram(binwidth=.1, colour="black", fill="white") + labs(x = "Log of Amount")
log_payment_plot <- ggplot(loans, aes(x=log_payment)) +
geom_histogram(binwidth=.1, colour="black", fill="white") + labs(x = "Log of Payment")
grid.arrange(log_amount_plot, log_payment_plot, nrow=1,
top="Movie Characteristics")
ggplot(aes(y = log_amount, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = amount, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = payment, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = log_payment, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = income, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = log_income, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = sqrt_openAcc, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = openAcc, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = sqrt_totalIlLim, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = totalIlLim, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = cube_rt_totalBal, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = log_amount, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = log_payment, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = sqrt_openAcc, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = cube_rt_totalBal, x = response), data = loans) + geom_boxplot()
ggplot(aes(y = sqrt_totalIlLim, x = response), data = loans) + geom_boxplot()
# Get data
require(DS705data)
data("normtemp")
# Remove Missing Values
normtemp <- na.omit(normtemp)
loess_line <- loess(hr~temp,normtemp)
{
# Create Scatter Plot
plot(normtemp$hr~normtemp$temp, xlab ="Body Temperature (F)", ylab = "Heart Rate (bpm)")
lines(predict(loess_line), col='red', lwd=2)
}
# Obtain estimated slope and y-intercept.
linear.heartratetemp.model<-with(normtemp,lm(hr~temp))
linear.heartratetemp.model
# Summary of linear model
summary(linear.heartratetemp.model)
# 95% confidence interval of rate of change heart rate for 1 degree change in temperature
confint(linear.heartratetemp.model)
# Compute confidence interval
temp_df <- data.frame( temp = 98.6 )
predict(linear.heartratetemp.model, temp_df , interval="confidence")
# Compute prediction interval
temp_df <- data.frame( temp = 98.6 )
predict(linear.heartratetemp.model, temp_df, interval="prediction")
# Add plotting libraries
require(ggplot2)
require(qqplotr)
require(grid)
require(gridExtra)
# Plot resids~pred, resids~temp, resids hist, resids normal prob, and box plot. Perform a Shapiro-Wilk test.
resids <- linear.heartratetemp.model$resid # extract residuals from model
temp <- normtemp$temp #temperature values
fit <- linear.heartratetemp.model$fitted.values #fitted values
resids_df <- data.frame(residuals = resids, pred = fit, temp = temp)
resids_pred <- ggplot(resids_df,aes(x=pred, y=residuals)) + geom_point()
resids_pred
#shapiro-wilk test for normality
shapiro.test(resids)
#shapiro-wilk test for normality
mean(resids)
resids_pred <- ggplot(resids_df,aes(x=pred, y=residuals)) + geom_point() + geom_hline(yintercept = 0)
resids_pred
# Plot resids~pred, resids~temp, resids hist, resids normal prob, and box plot. Perform a Shapiro-Wilk test.
resids <- linear.heartratetemp.model$resid # extract residuals from model
temp <- normtemp$temp #temperature values
fit <- linear.heartratetemp.model$fitted.values #fitted values
resids_df <- data.frame(residuals = resids, pred = fit, temp = temp)
#resids_pred <- ggplot(resids_df,aes(x=pred, y=residuals)) + geom_point()
resids_temp <- ggplot(resids_df,aes(x=temp, y=residuals)) + geom_point()
resids_temp
#https://cran.r-project.org/web/packages/qqplotr/vignettes/introduction.html
resid_normal_qq <- ggplot(data = resids_df, mapping = aes(sample = residuals)) +
stat_qq_band() +
stat_qq_line() +
stat_qq_point() +
labs(x = "Theoretical Quantiles", y = "Sample Quantiles") +
ggtitle("Normal Q-Q Plot")
resid_normal_qq
#https://cran.r-project.org/web/packages/qqplotr/vignettes/introduction.html
resid_normal_qq <- ggplot(data = resids_df, mapping = aes(sample = residuals)) +
stat_qq_band() +
stat_qq_line() +
stat_qq_point() +
labs(x = "Theoretical Quantiles", y = "Sample Quantiles") +
ggtitle("Normal Q-Q Plot")
# Add plotting libraries
require(ggplot2)
require(qqplotr)
install.packages("qqplotr")
require(qqplotr)
require(grid)
require(gridExtra)
#https://cran.r-project.org/web/packages/qqplotr/vignettes/introduction.html
resid_normal_qq <- ggplot(data = resids_df, mapping = aes(sample = residuals)) +
stat_qq_band() +
stat_qq_line() +
stat_qq_point() +
labs(x = "Theoretical Quantiles", y = "Sample Quantiles") +
ggtitle("Normal Q-Q Plot")
install.packages("ggplot2")
install.packages("qqplotr")
# Get data
require(DS705data)
data("normtemp")
# Remove Missing Values
normtemp <- na.omit(normtemp)
loess_line <- loess(hr~temp,normtemp)
{
# Create Scatter Plot
plot(normtemp$hr~normtemp$temp, xlab ="Body Temperature (F)", ylab = "Heart Rate (bpm)")
lines(predict(loess_line), col='red', lwd=2)
}
# Obtain estimated slope and y-intercept.
linear.heartratetemp.model<-with(normtemp,lm(hr~temp))
linear.heartratetemp.model
# Summary of linear model
summary(linear.heartratetemp.model)
# 95% confidence interval of rate of change heart rate for 1 degree change in temperature
confint(linear.heartratetemp.model)
# Compute confidence interval
temp_df <- data.frame( temp = 98.6 )
predict(linear.heartratetemp.model, temp_df , interval="confidence")
# Compute prediction interval
temp_df <- data.frame( temp = 98.6 )
predict(linear.heartratetemp.model, temp_df, interval="prediction")
# Add plotting libraries
require(ggplot2)
require(qqplotr)
require(grid)
require(gridExtra)
# Plot resids~pred, resids~temp, resids hist, resids normal prob, and box plot. Perform a Shapiro-Wilk test.
resids <- linear.heartratetemp.model$resid # extract residuals from model
temp <- normtemp$temp #temperature values
fit <- linear.heartratetemp.model$fitted.values #fitted values
resids_df <- data.frame(residuals = resids, pred = fit, temp = temp)
resids_pred <- ggplot(resids_df,aes(x=pred, y=residuals)) + geom_point() + geom_hline(yintercept = 0)
resids_pred
#resids_pred <- ggplot(resids_df,aes(x=pred, y=residuals)) + geom_point()
resids_temp <- ggplot(resids_df,aes(x=temp, y=residuals)) + geom_point()
resids_temp
#https://cran.r-project.org/web/packages/qqplotr/vignettes/introduction.html
resid_normal_qq <- ggplot(data = resids_df, mapping = aes(sample = residuals)) +
stat_qq_band() +
stat_qq_line() +
stat_qq_point() +
labs(x = "Theoretical Quantiles", y = "Sample Quantiles") +
ggtitle("Normal Q-Q Plot")
resid_normal_qq
resids_boxplot <- ggplot(aes(y = residuals), data = resids_df) + geom_boxplot() +
theme(axis.title.x=element_blank(),axis.text.x=element_blank(),axis.ticks.x=element_blank())
resids_hist <- ggplot(data=resids_df, aes(residuals)) + geom_histogram(breaks=seq(-15, 15, by=1))
grid.arrange(resids_boxplot, resids_hist,nrow=1, ncol=2)
#shapiro-wilk test for normality
shapiro.test(resids)
#Check that the mean of the residuals is 0.
mean(resids)
