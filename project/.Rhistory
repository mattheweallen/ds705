hist(loans$totalBal)
hist(loans$totalIlLim)
summary(loans)
#import data
loans <- read.csv2("C:/Users/matt/source/repos/ds705/project/loans50k.csv", header = TRUE, sep = ",")
loans$response <- loans$status
levels(loans$response)[levels(loans$response)==c("Charged Off")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Default")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Fully Paid")] <- "Good"
loans <- loans[which(loans$response=="Bad" | loans$response=="Good"), ]
#remove unuused levels
loans$response <- factor(loans$response)
#loans <- loans[loans$response == c("Good","Bad"),]
table(loans$response)
#
#columns_to_keep <- c("response", "income", "amount", "rate", "grade", "debtIncRat", "length")
#
columns_to_keep <- c("response","amount","payment","home","income","delinq2yr","inq6mth","openAcc","totalBal","totalIlLim")
loans <- loans[columns_to_keep]
summary(loans)
View(loans)
loans$income <- as.numeric(as.character(loans$income))
loans$payment <- as.numeric(as.character(loans$payment))
hist(loans$amount)
hist(loans$payment)
hist(loans$income)
hist(loans$delinq2yr)
hist(loans$inq6mth)
hist(loans$openAcc)
hist(loans$totalBal)
hist(loans$totalIlLim)
knitr::opts_chunk$set(echo = TRUE)
#import data
loans <- read.csv2("C:/Users/matt/source/repos/ds705/project/loans50k.csv", header = TRUE, sep = ",")
loans$response <- loans$status
levels(loans$response)[levels(loans$response)==c("Charged Off")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Default")] <- "Bad"
levels(loans$response)[levels(loans$response)==c("Fully Paid")] <- "Good"
loans <- loans[which(loans$response=="Bad" | loans$response=="Good"), ]
#remove unuused levels
loans$response <- factor(loans$response)
#
#columns_to_keep <- c("response", "income", "amount", "rate", "grade", "debtIncRat", "length")
#
columns_to_keep <- c("response","amount","payment","home","income","delinq2yr","inq6mth","openAcc","totalBal","totalIlLim")
loans <- loans[columns_to_keep]
loans$income <- as.numeric(as.character(loans$income))
loans$payment <- as.numeric(as.character(loans$payment))
hist(loans$amount)
hist(loans$amount^2)
hist(sqrt(loans$amount))
hist(cuberoot(loans$amount))
hist((loans$amount)^(1/3))
hist((loans$amount)^(1/3.0))
hist(log(loans$amount))
hist(sqrt(loans$amount))
hist(loans$payment)
hist(sqrt(loans$payment))
hist(log(loans$income))
hist(loans$delinq2yr)
hist(sqrt(loans$delinq2yr))
hist(log(loans$delinq2yr))
hist(loans$delinq2yr)
hist(loans$inq6mth)
hist(sqrt(loans$delinq2yr)) #maybe remove?
hist((loans$delinq2yr)^(1/3)) #maybe remove?
hist(log(1+loans$delinq2yr)) #maybe remove?
hist(loans$inq6mth)
hist(loans$openAcc)
hist(loans$totalBal)
hist(log(loans$totalBal))
hist(log(loans$totalIlLim))
summarize(loans$delinq2yr)
summary(loans$delinq2yr)
summary(loans$inq6mth)
hist(loans$delinq2yr) #do not transform does not appear to help
summary(loans$delinq2yr)
hist(loans$inq6mth)
hist(loans$openAcc)
hist(sqrt(loans$openAcc))
#https://stats.stackexchange.com/questions/11406/boxplot-with-respect-to-two-factors-using-ggplot2-in-r
library(ggplot2)
#https://stats.stackexchange.com/questions/11406/boxplot-with-respect-to-two-factors-using-ggplot2-in-r
require(ggplot2)
ggplot(aes(y = amount, x = response), data = loans) + geom_boxplot()
hist(loans$delinq2yr[which(loans$response == "Good")])
hist(loans$delinq2yr[which(loans$response == "Bad")])
hist(loans$delinq2yr[which(loans$response == "Good")])
hist(loans$inq6mth[which(loans$response == "Good")])
hist(loans$inq6mth[which(loans$response == "Bad")])
hist(loans$inq6mth[which(loans$response == "Good")])
hist(loans$openAcc[which(loans$response == "Good")])
hist(loans$openAcc[which(loans$response == "Bad")])
mean(loans$openAcc[which(loans$response == "Good")])
mean(loans$openAcc[which(loans$response == "Bad")])
median(loans$openAcc[which(loans$response == "Good")])
median(loans$openAcc[which(loans$response == "Bad")])
#/*Script1*/
#\*Data Prep Block*\
library(tidyr)
library(dplyr)
library(lubridate)
library(ggplot2)
library(DMwR)
#library(ltsa)
library(tscount)
#library(timetk)
run.plots <- FALSE #set to TRUE if want to run plots, FALSE otherwise
# Read file into R, check variable type and number of observations
warranty <- read.csv("C:/Data Analytics/Port R code into Alteryx/warranty.csv", stringsAsFactors = FALSE)
#warranty <- read.Alteryx("#2", mode="data.frame")
# convert date to POSIXct
warranty$mfg.date <- as.Date(as.POSIXct(warranty$mfg.date, tz = "", format="%Y-%m-%d" ))
warranty$service.begin.date <- as.Date(as.POSIXct(warranty$service.begin.date, tz = "", format="%Y-%m-%d" ))
warranty$adis <- as.Date(as.POSIXct(warranty$adis, tz = "", format="%Y-%m-%d" ))
#create 4 variables for mfg_week, mfg_month, service_week, service_month
warranty <- warranty %>%
filter(cof.level.3 == "ALTERNATOR 120 AMP") %>%
mutate(mfg_week = format(mfg.date, format="%Y/%U"),
mfg_month = format(mfg.date, format="%Y/%m"),
service_week = format(service.begin.date, format="%Y/%U"),
service_month = format(service.begin.date, format="%Y/%m"))
#nrow(df) #168679
#Read Population data set
population <- read.csv("C:/Data Analytics/Port R code into Alteryx/population.csv", stringsAsFactors = FALSE)
#population <- read.Alteryx("#1", mode="data.frame")
#Replace adis date with mfg.date if adis is blank
population$adis <- as.character(ifelse(population$adis=="",population$mfg.date,population$adis))
# convert date to POSIXct
population$mfg.date <- as.Date(as.POSIXct(population$mfg.date, tz = "", format="%Y-%m-%d"))
population$adis <- as.Date(as.POSIXct(population$adis, tz = "", format="%Y-%m-%d"))
# convert date to POSIXct, meallen date format is a below, can add multiple formats if needed
#df_pop$mfg.date <- as.POSIXct(df_pop$mfg.date, tz = "", format="%m/%d/%Y")
#df_pop$adis <- as.POSIXct(df_pop$adis, tz = "", format="%m/%d/%Y")
population <- population %>%
mutate(mfg_week = format(mfg.date, format="%Y/%U"),
mfg_month = format(mfg.date, format="%Y/%m"),
adis_week = format(adis, format="%Y/%U"),
adis_month = format(adis, format="%Y/%m"))
#nrow(df_pop) #171191
#add 3 years to adis add expired and active variables
population$adis_36m <- (population$adis+days(365*3))
population$expired <- ifelse(population$adis_36m < Sys.Date(),1,0)
population$active <- ifelse(population$adis_36m < Sys.Date(),0,1)
#1 Output: labeled #1, this output will consist of the R result 
#write.Alteryx(warranty, 1)
#write.Alteryx(population, 2)
##########################################/*Script2*/
#\*Anomaly Detection Block*\
library(tidyr)
library(dplyr)
library(lubridate)
#warranty <- read.Alteryx("#1", mode="data.frame")
#population <- read.Alteryx("#2", mode="data.frame")
#assign values to run anomaly detection for cof.level.3 and mfg date
#Logic to get production count--from population data set join on product.line get count of
#unique serial number and join on month/year
#create empty data frame to store results
#result <- data.frame(Part.number=character(),Year.month=character(),Freq=numeric(),cluster=integer(),
#Anomaly=character(),Date.type=character(),Anomaly.for=character(),Anomaly.type=character())
# consider last 12 months data for analysis from today (current date)
#12/27/2017 consider records for 100% expiration i.e mfg.date > Sys.Date()-days(365*3)
claim_count <- table(warranty$cof.level.3, warranty$mfg_month)
#get product.line,mfg_month,cof.level.3 from warranty
#usn means unique serial number
usn <- warranty %>%
dplyr::select(product.line,mfg_month,cof.level.3) %>%
rename("Var1" = cof.level.3,"Var2" = mfg_month)
# avoid duplicate model no for same Year/Month and part #
usn <- usn[!duplicated(usn[,c("product.line","Var2","Var1")]),]
#join warranty and population to get unique serial number
df_join <- population %>%
dplyr::select(product.line, mfg_month, unit.serial.number,expired, active) %>%
rename("Var2" = mfg_month) %>%
inner_join(usn, by = c("product.line","Var2"))
# avoid duplicate unit_srl_nbr for same Year/Month and product.line
df_join <- df_join[!duplicated(df_join[,c("product.line","Var2","unit.serial.number","Var1")]),]
#print(paste0("df_j rows count ", nrow(df_j)))
#write.Alteryx(df_join, 1)
claim_count<- data.frame(claim_count)
#write.Alteryx(claim_count, 2)
##########################################/*Script3*/
library(tidyr)
library(dplyr)
library(lubridate)
library(ggplot2)
library(DMwR)
#df_join <- read.Alteryx("#1", mode="data.frame")
# claim_count is data frame with cof.level.3/Dealer with count by mfg month
#claim_count <- read.Alteryx("#2", mode="data.frame")
####Hierarchical clustering Regular data prep####
#select observations with Freq > 3 and cof.level.3/Dealer not blank
#claim_count <- claim_count[which(!(claim_count$Var1 == '')),]
claim_count <- claim_count[which((claim_count$Freq > 3) & !(claim_count$Var1 == '')),]
claim_count$Var1 <- as.character(claim_count$Var1)
claim_count$Var2 <- as.character(claim_count$Var2)
uq_parts <- unique(claim_count$Var1)
#write.Alteryx(uq_parts, 5)
#containers to hold result
datalist = list()
df_result=''
result <- data.frame(Part.number=character(),Year.month=character(),Freq=numeric(),cluster=integer(),
Anomaly=character(),Date.type=character(),Anomaly.for=character(),Anomaly.type=character())
#loop throuth each cof.level.3/Dealer and run hc for each one and append the results
for (i in 1:length(uq_parts)){
#for (i in 1:1){
pc <-''
df_part<-''
df_part <- df_join[df_join$Var1 == uq_parts[i],]
#Production count by Year/Month
# it is possible not to get any records for uq_parts[i] in production data set
# i.e. df_join add if condition in order to avoid error
if (nrow(df_part) > 0) {
pc <- table(df_part$Var2)
pc <- data.frame(pc)
pc <- pc %>%
rename("Prod.Count" = Freq,
"Var2"= Var1)
pc$Var2 <- as.character(pc$Var2)
# expired, active by year/month
df_exp <- df_part %>%
group_by(Var2) %>%
summarize(expired.cnt = sum(expired, na.rm=TRUE),
active.cnt = sum(active, na.rm=TRUE))
df_exp <- data.frame(df_exp)
df_exp$exp.percent <- (df_exp$expired.cnt/(df_exp$expired.cnt+df_exp$active.cnt)*100)
}
temp=''
final1=''
temp <- data.frame(claim_count[claim_count$Var1 == uq_parts[i],])
if (nrow(df_part) > 0) {
final1 <- temp %>%
left_join(pc, by = "Var2")
nrow(pc)
#Replace NA with zero for Prod.Count columns
final1<- filter(final1,final1$Prod.Count!= 0,!is.na(final1$Prod.Count))
final1 <- final1 %>%
left_join(df_exp, by = "Var2")
}
final1 <- final1 %>%
mutate(Rate = final1$Freq/final1$Prod.Count)
#order data frame by column by which you would do anomaly detection in order to get
#clustering group properly, this way higher values will belong to grp. 2 (Anomalous grp)
final1 <- final1[order(final1$Rate),]
#Hierarchical clustring
anom.d <- dist(final1[, "Rate"],method = "euclidean")
n <- as.integer(attr(anom.d, "Size"))
#must have n >= 2 objects to cluster otherwise get error:
#https://github.com/SurajGupta/r-source/blob/master/src/library/stats/R/hclust.R
if (n > 2) {
anom.hc <- hclust(d=anom.d, method="complete")
grp1 <- cutree(anom.hc, k=2) # cut tree into 2 clusters
m1<-as.matrix(grp1)
final1 <- data.frame(final1, m1)
nk <- ''
anomaly.scores <- ''
#nk <- nrow(final1)-1
if ( nrow(final1) > 4){
nk <- nrow(final1)-2
} else {
nk <- nrow(final1)-1
}
####LOF Scores: assign nk value for number of neighbors####
anomaly.scores <- lofactor(final1[, "Rate"], k=nk)
final1$Anomaly.score <- anomaly.scores
df_result <- final1 %>%
rename("Part.number" = Var1,
"Year.month" = Var2,
"cluster" = m1) %>%
mutate(Anomaly = ifelse(final1$m1==1,"N","Y"),
Date.type = "Mfg.Date",
Anomaly.for = "cof.level.3",
Anomaly.type = "Regular",
Freq.Detrend = 0)
#write.Alteryx(df_result, 2)
#datalist[[i]] <- df_result
#bind rows for each cof.level.3/Dealer
result <- dplyr::bind_rows(result,df_result)
} # end if (n > 2)
} # For uq_parts
#create empty data frame to store results
#write.Alteryx(result, 3)
#write.Alteryx(claim_count,4)
##########################################/*Script4*/
#\*Time Series Block*\
library(tidyr)
library(dplyr)
library(lubridate)
library(ggplot2)
library(DMwR)
library(tscount)
library(timeSeries)
#library(reshape2)
#install.packages("timetk",repos="http://cran.rstudio.com")
#library(timetk)
#result <- read.Alteryx("Result", mode="data.frame")
# claim_count is data frame with cof.level.3/Dealer with count by mfg month
#claim_count <- read.Alteryx("claim_count", mode="data.frame")
#x <- data.frame(x)
#select observations with Freq > 3 and cof.level.3/Dealer not blank
#x <- x[which(!(x$Var1 == '')),]
claim_count <- claim_count[which((claim_count$Freq > 3) & !(claim_count$Var1 == '')),]
claim_count$Var1 <- as.character(claim_count$Var1)
claim_count$Var2 <- as.character(claim_count$Var2)
uq_parts <- unique(claim_count$Var1)
create_timeseries_index <- function(begin_year, begin_month, end_year, end_month) {
num_months = (end_year - begin_year) * 12 - (begin_month-1) + end_month # calculate number of months
all_dates <- seq(as.Date(paste(begin_year,begin_month,1,sep="/")), by = "month", length.out = num_months)
years <- substr(all_dates,1,4)
months <- substr(all_dates,6,7)
paste(years,months, sep = "/")
}
#####////////////////////****Model by part number****////////////////////
##ts1 for part number
# get part nos. which has data from 2013 to 2017 so that we can train model on
#year 2013 to 2015 and test for year 2016 to 2017 (not all the parts has enough data to train)
part_year <- result %>%
group_by(Part.number) %>%
dplyr::summarize(min_year = min(substr(Year.month,1,4)),
max_year = max(substr(Year.month,1,4))) %>%
dplyr::filter(min_year == "2013" , max_year == "2017")
#head(part_year,5)
uq_cof_level3 <- unique(part_year$Part.number)
for (p in 1:length(uq_cof_level3)) {
ts1 <- result %>%
dplyr::filter(Part.number == uq_cof_level3[p]) %>%
dplyr::select(Year.month,Freq,Prod.Count,expired.cnt,active.cnt) %>%
rename("claim.cnt" = Freq)
ts1 <- ts1[order(ts1$Year.month),]
ts1 <- data.frame(ts1)
ts1$linearTrend <- seq(along = ts1$Prod.Count)/12
#write.Alteryx(ts1,4)
values <- ts1[,c("claim.cnt","Prod.Count","active.cnt","expired.cnt","linearTrend")]
## It is working till here, continue to debug from here on##
myts <- ts(values,start=c(2013, 1), end=c(2017, 07), frequency=12)
temp <- (time(myts))
tms <- date_decimal(myts)
#write.Alteryx(data.frame(Y=as.matrix(myts),temp) ,5)
##***********###MODEL TO PREDICT PRODUCTION COUNT###************
##TRAIN MODEL ON 2013-2015 AND PREDICT ON 2016/2017###
#class(myts)
#tsp_y <- myts[, "Prod.Count"]
tsp_y <- myts
tspy1_1315 <- window(tsp_y, start = 2013, end = c(2015,12))
#Simple raw count prediction model, it doesn't take into updated production count
fitp1315 <- tscount::tsglm(tspy1_1315, model=list(past_obs = c(1, 12)), link = "log", distr = "poisson")####
plot(fitp1315)
#write.Alteryx(data.frame(fitp1315$n_obs),3)
tspy_1617 <- window(tsp_y, start = 2016, end = c(2017,07))
#write.Alteryx(data.frame(tspy_1617), 2)
#n.ahead was n.ahead=24 now we changed it to n.ahead=3
yp1617 <- predict(fitp1315,n.ahead = 19,level = 0.9, global = TRUE)$median
#write.Alteryx(data.frame(as.matrix(yp1617)),1)
#round(yp1617)
#Add a time column called index start at 2016 end 2017,07
##########################################################################
#model_matrix <- timetk::tk_tbl(yp1617)
model_matrix <- data.frame(as.matrix(yp1617))
colnames(model_matrix)<- "value"
model_matrix$index <- create_timeseries_index(2016, 1, 2017, 7)
#model_matrix <- data.frame(model_matrix)
### add predicted production count for year 2016/2017 and create a model to predict monthly claims
#month.abb is system generated constant
#add 0 to m_num if its 1 to 9 in order to match like ts1 data frame to join on Year.month
model_matrix <- model_matrix %>%
rename("month.year" = index,
"Pred.Prod" = value) %>%
mutate( month.year = as.character(month.year),
m_abr = substr(month.year,1,3),
m_num = match(m_abr, month.abb),
m_num = as.character(m_num),
m_num = ifelse(nchar(m_num)==1,paste0("0",m_num),m_num),
yr = substr(month.year,5,8),
Pred.Prod = round(Pred.Prod),
Year.month = paste(yr,m_num,sep="/"))
ts2 <- ts1 %>%
left_join(model_matrix, by = "Year.month") %>%
dplyr::select(Year.month,claim.cnt,Prod.Count,expired.cnt,active.cnt,linearTrend,Pred.Prod)
#copy of ts2 with NA values pred.prod for year 2013 to 2015
ts2$Pred.Prod <- ifelse(((ts2$Pred.Prod) < ts2$Prod.Count), ts2$Prod.Count,ts2$Pred.Prod)
model2 <- ts2
ts2$Pred.Prod <- ifelse(is.na(ts2$Pred.Prod),ts2$Prod.Count,ts2$Pred.Prod)
# plot actual vs. predicted Production count
model2 <- model2 %>%
dplyr::select(Year.month,Prod.Count,Pred.Prod) %>%
gather(key, value, Prod.Count, Pred.Prod)
#Model with one predictor using pred.prod (predicted prod) as explanatory variable
#train data 2013-2015 test 2016/2017
v2 <- ts2[,c("claim.cnt","Prod.Count","active.cnt","expired.cnt","linearTrend","Pred.Prod")]
myts2 <- ts(v2,start=c(2013, 1), end=c(2017, 12), frequency=12)
ts2_y <- myts2[, "claim.cnt"]
ts2_x <- cbind(Prod.Count = myts2[, c("Pred.Prod")])
ts2x_1315 <-  window(ts2_x, start = 2013, end = c(2015,12))
ts2y_1315 <- window(ts2_y, start = 2013, end = c(2015,12))
pclaimsfit1315 <- tsglm(ts2y_1315, model=list(past_obs = c(1, 12)), link = "log", distr = "poisson", xreg=ts2x_1315)
summary(pclaimsfit1315)
ts2x_1617 <- window(ts2_x, start = 2016, end = c(2017,12))
ts2y_1617 <- window(ts2_y, start = 2016, end = c(2017,12))
py1617 <- predict(pclaimsfit1315, n.ahead = 24, level = 0.9, global = TRUE, newxreg = ts2x_1617)$pred
round(py1617)
#prepare data set for gg plot
#md3 <- timetk::tk_tbl(py1617)
#md3 <- data.frame(md3)
md3 <- timeSeries::as.data.frame(py1617)
md3 <- md3 %>%
rename("month.year" = index,
"Pred.claim" = value) %>%
mutate( month.year = as.character(month.year),
m_abr = substr(month.year,1,3),
m_num = match(m_abr, month.abb),
m_num = as.character(m_num),
m_num = ifelse(nchar(m_num)==1,paste0("0",m_num),m_num),
yr = substr(month.year,5,8),
Pred.claim = round(Pred.claim),
Year.month = paste(yr,m_num,sep="/")) %>%
dplyr::select(Year.month,Pred.claim)
model3 <- ts2 %>%
left_join(md3, by = "Year.month") %>%
dplyr::select(Year.month,claim.cnt,Pred.claim)
model3 <- model3 %>%
gather(key, value, claim.cnt, Pred.claim)
}# End of part # (cof_level3) for loop
institution <- c("Bank", "Credit Union")
outstanding <- c(70,66)
not_outstanding <- c(150,81)
ratings <- matrix(c(outstanding, not_outstanding),ncol=2)
colnames(ratings) <- c("Outstanding","Not Outstanding")
rownames(ratings) <- institution
ratings_with_margins <- addmargins(as.table(ratings))
ratings_with_margins
# Construct 95% Confidence Interval for proportion of Credit Unions rated as Outstanding.
prop.test(ratings_with_margins["Credit Union","Outstanding"],ratings_with_margins["Credit Union","Sum"],correct = FALSE)$conf.int
# Insert your R code here.
prop.test(abs(ratings_with_margins["Credit Union","Outstanding"]-ratings_with_margins["Bank","Outstanding"]),abs(ratings_with_margins["Credit Union","Sum"]-ratings_with_margins["Bank","Sum"]),correct = FALSE)$conf.int
# what is the estimated risk of a bank not being rated as outstanding?
bank_risk_not_outstanding <- ratings_with_margins["Bank","Not Outstanding"]/ratings_with_margins["Bank","Sum"]
bank_risk_not_outstanding
# what is the estimated risk of a Credit not being rated as outstanding?
credit_union_risk_not_outstanding <- ratings_with_margins["Credit Union","Not Outstanding"]/ratings_with_margins["Credit Union","Sum"]
credit_union_risk_not_outstanding
# Relative risk banks not outstanding compared to credit unions
bank_risk_not_outstanding/credit_union_risk_not_outstanding
# Estimated odds of credit union being rated as outstanding
#calculate by manually
odds_credit_union_outstanding <- (1-credit_union_risk_not_outstanding)/credit_union_risk_not_outstanding
odds_credit_union_outstanding
#calculate with mosaic
require(mosaic)
#calculate with mosaic
require(mosaic)
oddsRatio(ratings,verbose = TRUE)
```{r echo=FALSE}
# Estimated odds of credit union being rated as outstanding
#calculate by manually
odds_credit_union_outstanding <- (1-credit_union_risk_not_outstanding)/credit_union_risk_not_outstanding
odds_credit_union_outstanding
#calculate with mosaic
require(mosaic)
oddsRatio(ratings,verbose = TRUE)
#manual calculation of bank being rated as outstanding
odds_bank_outstanding <- (1-bank_risk_not_outstanding)/bank_risk_not_outstanding
odds_bank_outstanding
# Compute the estimated odds ratio of being rated as outstanding for credit unions compared to banks.
odds_credit_union_outstanding/odds_bank_outstanding
# Run Chi Squared test
observed <- c(28,44,54,39)
proportions <- c(.13,.32,.38,.17)
chisq.test(x=observed,p=proportions)
# Compute expected cell counts
expected_counts <- sum(observed) * proportions
expected_counts
# Insert your R code here. MEALLEN mayb plot with expected_counts?
barplot(observed,names.arg=c("Under 18", "18 to 35", "36 to 50","Over 50"),
ylab="Count",col=c("purple","blue","red","green"), main = "Sample of Online Purchases by Age Group")
# Create contingency table from anesthesia data
require(DS705data)
data("anesthesia")
anesthetic_nausea <- with(anesthesia,table(anesthetic,nausea))
addmargins(anesthetic_nausea)
barplot(anesthetic_nausea,xlab="Region", ylab="Frequency",
col=c("khaki","cyan"),legend=rownames(anesthetic_nausea),beside=T)
# Insert your R code here.
#p 521
chisq.test(anesthetic_nausea, correct=FALSE)
# Create 2X2 matrix for seat belt data
age_group <- c("Teen", "Senior")
always_wear <- c(17,12)
not_always_wear <- c(2,8)
seat_belt_usage <- matrix(c(always_wear, not_always_wear),ncol=2,byrow = TRUE)
colnames(seat_belt_usage) <- age_group
rownames(seat_belt_usage) <- c("always_wear", "not_always_wear")
seat_belt_usage
# Insert your R code here.
#p.511-512 Fisher Exact Test
#fisher.test
fisher.test(seat_belt_usage,alternative="two.sided")
```{r results="hide" }
# Estimated odds of credit union being rated as outstanding
#calculate by manually
odds_credit_union_outstanding <- (1-credit_union_risk_not_outstanding)/credit_union_risk_not_outstanding
odds_credit_union_outstanding
#calculate with mosaic
require(mosaic)
oddsRatio(ratings,verbose = TRUE)
```{r include=FALSE}
# Estimated odds of credit union being rated as outstanding
#calculate by manually
odds_credit_union_outstanding <- (1-credit_union_risk_not_outstanding)/credit_union_risk_not_outstanding
odds_credit_union_outstanding
#calculate with mosaic
require(mosaic)
oddsRatio(ratings,verbose = TRUE)
